---
phase: 06-api-integrations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/amadeus.ts
  - src/lib/api/bls.ts
autonomous: true
user_setup:
  - service: amadeus
    why: "Flight pricing API for real fare estimates"
    env_vars:
      - name: AMADEUS_CLIENT_ID
        source: "https://developers.amadeus.com/my-apps -> Create App -> API Key"
      - name: AMADEUS_CLIENT_SECRET
        source: "https://developers.amadeus.com/my-apps -> Create App -> API Secret"
      - name: AMADEUS_PRODUCTION
        source: "Set to 'true' for production, omit or 'false' for test environment"
    dashboard_config:
      - task: "Create a Self-Service API app on Amadeus developer portal"
        location: "https://developers.amadeus.com/my-apps"
  - service: bls
    why: "Bureau of Labor Statistics CPI data for inflation projections"
    env_vars:
      - name: BLS_API_KEY
        source: "https://data.bls.gov/registrationEngine/ -> Register -> receive key via email"

must_haves:
  truths:
    - "Amadeus client can authenticate via OAuth2 and return a FlightQuote for a given origin/destination/date"
    - "BLS client can fetch CPI data for a year range and compute an annual inflation rate"
    - "Amadeus quota tracking increments atomically via Redis INCR and blocks at 1800/2000 monthly limit"
    - "Both clients return null/fallback values on API failure instead of throwing"
  artifacts:
    - path: "src/lib/api/amadeus.ts"
      provides: "Amadeus OAuth + flight quote search + quota tracking"
      exports: ["searchFlightOffers", "checkQuotaRemaining", "FlightQuote"]
    - path: "src/lib/api/bls.ts"
      provides: "BLS CPI data fetch + annual inflation rate computation"
      exports: ["fetchCpiData", "computeAnnualInflationRate", "getLatestInflationRate", "CpiDataPoint"]
  key_links:
    - from: "src/lib/api/amadeus.ts"
      to: "src/lib/redis.ts"
      via: "getRedis() for quota counter INCR"
      pattern: "getRedis.*incr"
    - from: "src/lib/api/bls.ts"
      to: "src/lib/redis.ts"
      via: "cacheGet/cacheSet for 30d CPI cache"
      pattern: "cacheGet|cacheSet"
---

<objective>
Build the two pure-logic API client modules: an Amadeus flight quote client with OAuth2 token caching and Redis quota tracking, and a BLS CPI client with inflation rate computation and 30d Redis cache.

Purpose: These are the foundational API wrappers that all downstream route handlers, cron jobs, and graceful degradation depend on. Neither client has any UI or route handler -- they are pure server-side library code.

Output: `src/lib/api/amadeus.ts` and `src/lib/api/bls.ts` ready to be consumed by route handlers and cron jobs in Plan 06-02.
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/redis.ts
@src/lib/engine/verified-datum.ts
@src/lib/constants/flight-hubs.ts
@.planning/phases/06-api-integrations/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Amadeus flight quote client with OAuth2 and quota tracking</name>
  <files>src/lib/api/amadeus.ts</files>
  <action>
Create `src/lib/api/amadeus.ts` with the following:

**Environment setup:**
- `AMADEUS_BASE` switches between `https://test.api.amadeus.com` and `https://api.amadeus.com` based on `process.env.AMADEUS_PRODUCTION === "true"`.

**OAuth2 token management:**
- Module-level `cachedToken: { token: string; expiresAt: number } | null = null`.
- `getToken()` async function: returns cached token if `Date.now() < expiresAt - 60_000` (60s buffer). Otherwise, POST to `${AMADEUS_BASE}/v1/security/oauth2/token` with `Content-Type: application/x-www-form-urlencoded`, body = `grant_type=client_credentials&client_id=AMADEUS_CLIENT_ID&client_secret=AMADEUS_CLIENT_SECRET`. Parse response `{ access_token, expires_in }`. Cache as `{ token: access_token, expiresAt: Date.now() + expires_in * 1000 }`. Throw on non-ok response.

**Quota tracking (Redis INCR pattern):**
- `QUOTA_KEY = "amadeus:monthly_calls"`, `MONTHLY_LIMIT = 1800`.
- `checkAndIncrementQuota()` async: calls `getRedis()`. If null (no Redis), return `true` (dev mode, no tracking). Otherwise `redis.incr(QUOTA_KEY)`. If count === 1, compute `secondsRemaining` until first day of next month, call `redis.expire(QUOTA_KEY, secondsRemaining)`. If count > MONTHLY_LIMIT, call `redis.decr(QUOTA_KEY)` and return `false`. Otherwise return `true`.
- `checkQuotaRemaining()` async: exported helper. Gets Redis, reads current count via `redis.get(QUOTA_KEY)`, returns `{ used: number, limit: MONTHLY_LIMIT, remaining: number, exhausted: boolean }`. Returns `{ used: 0, limit: 1800, remaining: 1800, exhausted: false }` if no Redis.

**Flight search:**
- Export `FlightQuote` interface: `{ origin: string, destination: string, price: number, currency: string, airline: string, queriedAt: string }`.
- `searchFlightOffers(origin: string, destination: string, departureDate: string): Promise<FlightQuote | null>` exported:
  1. Call `checkAndIncrementQuota()`. If false, return null (quota exhausted).
  2. Call `getToken()`.
  3. GET `${AMADEUS_BASE}/v2/shopping/flight-offers` with query params: `originLocationCode=origin, destinationLocationCode=destination, departureDate, adults=1, nonStop=false, currencyCode=USD, max=5`.
  4. If response not ok, return null.
  5. Parse response JSON. Extract `data` array. If empty, return null.
  6. Find cheapest offer: reduce over offers comparing `parseFloat(o.price.grandTotal)`.
  7. Return `{ origin, destination, price: parseFloat(cheapest.price.grandTotal), currency: cheapest.price.currency, airline: cheapest.validatingAirlineCodes?.[0] ?? "Unknown", queriedAt: new Date().toISOString() }`.
  8. Wrap entire function body in try/catch. On error, log `console.error("Amadeus search failed:", err)` and return null. Never throw.

**Important:** Use direct `fetch` calls, NOT the `amadeus` npm SDK (CJS-only, bundling risk in Next.js 16 per research). No new dependencies needed.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the file exports `searchFlightOffers`, `checkQuotaRemaining`, and `FlightQuote`.
  </verify>
  <done>
`src/lib/api/amadeus.ts` exists, exports FlightQuote type, searchFlightOffers function (returns FlightQuote | null), and checkQuotaRemaining function. Uses direct fetch (no SDK). Quota tracking uses Redis INCR with auto-expire TTL. All errors caught and return null.
  </done>
</task>

<task type="auto">
  <name>Task 2: BLS CPI client with inflation rate computation and cache</name>
  <files>src/lib/api/bls.ts</files>
  <action>
Create `src/lib/api/bls.ts` with the following:

**Constants:**
- `BLS_API_URL = "https://api.bls.gov/publicAPI/v2/timeseries/data/"`.
- `CPI_SERIES_ID = "CUUR0000SA0"` (CPI-U, All Items, US City Average, Not Seasonally Adjusted).
- `CPI_CACHE_KEY = "bls:cpi_annual_rate"`.
- `FALLBACK_INFLATION_RATE = 0.035` (3.5% -- matches the current hardcoded value in PortfolioOverview.tsx and HeroSummary.tsx).

**Types:**
- Export `CpiDataPoint`: `{ year: string, period: string, value: number, periodName: string }`.

**CPI data fetch:**
- `fetchCpiData(startYear: number, endYear: number): Promise<CpiDataPoint[]>` exported:
  1. POST to `BLS_API_URL` with JSON body: `{ seriesid: [CPI_SERIES_ID], startyear: String(startYear), endyear: String(endYear), registrationkey: process.env.BLS_API_KEY }`.
  2. If no `BLS_API_KEY` env var, omit `registrationkey` from body (falls back to v1 limits -- still works, just lower quota).
  3. If response not ok, return empty array.
  4. Parse JSON. Check `json.status === "REQUEST_SUCCEEDED"`. If not, return empty array.
  5. Extract `json.Results?.series?.[0]?.data`. If missing, return empty array.
  6. Map to CpiDataPoint array: `{ year: d.year, period: d.period, value: parseFloat(d.value), periodName: d.periodName }`.
  7. Wrap in try/catch, return empty array on error.

**Inflation rate computation:**
- `computeAnnualInflationRate(data: CpiDataPoint[]): number` exported:
  1. First try: filter for `period === "M13"` (annual average). Sort by year descending. If >= 2 entries, compute `(current - previous) / previous` and return.
  2. Fallback: filter for `period === "M12"` (December values). Sort by year descending. If >= 2, compute same rate and return.
  3. Ultimate fallback: return `FALLBACK_INFLATION_RATE`.

**Cached inflation rate accessor:**
- `getLatestInflationRate(): Promise<{ rate: number; source: "bls_api" | "cached" | "fallback"; queriedAt: string | null }>` exported:
  1. Check Redis cache: `cacheGet<{ rate: number; queriedAt: string }>(CPI_CACHE_KEY)`. If cached, return `{ rate: cached.rate, source: "cached", queriedAt: cached.queriedAt }`.
  2. Try live fetch: current year and previous year via `fetchCpiData(currentYear - 1, currentYear)`.
  3. If data returned, compute rate via `computeAnnualInflationRate`, cache result with `cacheSet(CPI_CACHE_KEY, { rate, queriedAt: new Date().toISOString() }, "cpi_data")`.
  4. Return `{ rate, source: "bls_api", queriedAt: new Date().toISOString() }`.
  5. If fetch fails or returns empty, return `{ rate: FALLBACK_INFLATION_RATE, source: "fallback", queriedAt: null }`.

**Export** `FALLBACK_INFLATION_RATE` so downstream consumers can reference it for static fallback.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the file exports `fetchCpiData`, `computeAnnualInflationRate`, `getLatestInflationRate`, `CpiDataPoint`, and `FALLBACK_INFLATION_RATE`.
  </verify>
  <done>
`src/lib/api/bls.ts` exists, exports CpiDataPoint type, fetchCpiData (returns CpiDataPoint[]), computeAnnualInflationRate (returns number), getLatestInflationRate (cache-first with fallback). Uses Redis cache with "cpi_data" TTL preset. Falls back to 3.5% on any failure.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Both files exist at `src/lib/api/amadeus.ts` and `src/lib/api/bls.ts`
3. `amadeus.ts` imports from `@/lib/redis` (getRedis) -- no other new dependencies
4. `bls.ts` imports from `@/lib/redis` (cacheGet, cacheSet) -- no other new dependencies
5. Neither file imports from the `amadeus` npm package (direct fetch only)
6. Both files handle errors gracefully (return null/empty/fallback, never throw)
</verification>

<success_criteria>
- Two pure-logic API client modules exist with zero new npm dependencies
- Amadeus client handles OAuth2 token refresh with 60s buffer, quota tracking via Redis INCR, and returns FlightQuote or null
- BLS client fetches CPI data, computes annual inflation from M13/M12 periods, caches in Redis for 30 days, and falls back to 3.5%
- Both clients are server-side only (no "use client" directive) and ready for route handler consumption
</success_criteria>

<output>
After completion, create `.planning/phases/06-api-integrations/06-01-SUMMARY.md`
</output>
