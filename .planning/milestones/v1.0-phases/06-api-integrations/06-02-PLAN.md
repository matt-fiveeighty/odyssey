---
phase: 06-api-integrations
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/flights/quote/route.ts
  - src/app/api/inflation/cpi/route.ts
  - src/app/api/cron/warm-flights/route.ts
  - src/app/api/cron/refresh-cpi/route.ts
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "GET /api/flights/quote returns cached Amadeus data wrapped in VerifiedDatum or falls back to static estimates"
    - "GET /api/inflation/cpi returns cached BLS inflation rate wrapped in VerifiedDatum or falls back to 3.5%"
    - "Flight warm cron pre-caches all HUNTING_ROUTES airport pairs via Amadeus API in batched groups"
    - "CPI refresh cron fetches latest BLS data and updates the Redis cache"
    - "Cron endpoints reject unauthenticated requests (CRON_SECRET check)"
    - "vercel.json contains cron entries for warm-flights (monthly 1st) and refresh-cpi (monthly 15th)"
  artifacts:
    - path: "src/app/api/flights/quote/route.ts"
      provides: "Cache-first flight price endpoint returning VerifiedDatum"
      exports: ["GET"]
    - path: "src/app/api/inflation/cpi/route.ts"
      provides: "Cache-first inflation rate endpoint returning VerifiedDatum"
      exports: ["GET"]
    - path: "src/app/api/cron/warm-flights/route.ts"
      provides: "Batch Amadeus warming cron with quota-aware batching"
      exports: ["GET"]
    - path: "src/app/api/cron/refresh-cpi/route.ts"
      provides: "Monthly BLS CPI refresh cron"
      exports: ["GET"]
    - path: "vercel.json"
      provides: "Cron schedule entries for warm-flights and refresh-cpi"
      contains: "warm-flights"
  key_links:
    - from: "src/app/api/flights/quote/route.ts"
      to: "src/lib/redis.ts"
      via: "cacheGet for flight price lookup"
      pattern: "cacheGet.*flight:"
    - from: "src/app/api/flights/quote/route.ts"
      to: "src/lib/constants/flight-hubs.ts"
      via: "findBestRoutes for static fallback"
      pattern: "findBestRoutes"
    - from: "src/app/api/cron/warm-flights/route.ts"
      to: "src/lib/api/amadeus.ts"
      via: "searchFlightOffers for batch warming"
      pattern: "searchFlightOffers"
    - from: "src/app/api/cron/refresh-cpi/route.ts"
      to: "src/lib/api/bls.ts"
      via: "fetchCpiData + computeAnnualInflationRate"
      pattern: "fetchCpiData|computeAnnualInflationRate"
---

<objective>
Build the four API route handlers (two user-facing cache-first endpoints and two background cron jobs) plus the Vercel cron configuration.

Purpose: User-facing routes NEVER call external APIs directly -- they read from Redis cache and fall back to static estimates. Cron jobs populate the cache on schedule. This architecture protects API free tier quotas and ensures zero-latency responses.

Output: Two GET routes (/api/flights/quote, /api/inflation/cpi) serving VerifiedDatum-wrapped data, two cron endpoints (/api/cron/warm-flights, /api/cron/refresh-cpi) for background warming, and vercel.json cron entries.
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-api-integrations/06-01-SUMMARY.md

@src/lib/redis.ts
@src/lib/engine/verified-datum.ts
@src/lib/constants/flight-hubs.ts
@src/app/api/cron/scrape/route.ts
@src/lib/api/amadeus.ts
@src/lib/api/bls.ts
@vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cache-first route handlers for flights and inflation</name>
  <files>src/app/api/flights/quote/route.ts, src/app/api/inflation/cpi/route.ts</files>
  <action>
**Flight quote route -- `src/app/api/flights/quote/route.ts`:**

Create a GET handler:
1. Parse query params: `origin` (IATA code), `destination` (IATA code), `homeState` (optional, 2-letter state code for fallback lookup).
2. Validate: if `origin` or `destination` missing, return 400 `{ error: "Missing origin or destination" }`.
3. **Cache lookup:** Build key `flight:${origin}:${destination}`. Call `cacheGet<{ price: number; currency: string; airline: string; queriedAt: string }>(cacheKey)`.
4. **If cached:** Return 200 with `{ data: verified(cached.price, "https://api.amadeus.com/v2/shopping/flight-offers", cached.queriedAt, "Amadeus Flight Offers Search"), meta: { source: "amadeus_cached", airline: cached.airline, currency: cached.currency } }`.
5. **If not cached (fallback):** Use `findBestRoutes(homeState ?? "", "")` -- but actually we need the target state. Since we have origin/destination IATA codes but not necessarily the target state, look up the route from HUNTING_ROUTES by matching `from === origin && to === destination`. If found, use its `avgCost`. If not found, use 250 as generic fallback.
   - Actually simpler: import `HUNTING_ROUTES` directly, find route matching origin+destination, use its `avgCost`. If not found, default to 250.
   - Return 200 with `{ data: estimated(fallbackPrice, "Historical average from flight-hubs.ts"), meta: { source: "static_fallback" } }`.
6. Wrap in try/catch. On error, return fallback path (never 500).

Import from: `next/server` (NextResponse, NextRequest), `@/lib/redis` (cacheGet), `@/lib/engine/verified-datum` (verified, estimated), `@/lib/constants/flight-hubs` (HUNTING_ROUTES).

**Inflation CPI route -- `src/app/api/inflation/cpi/route.ts`:**

Create a GET handler:
1. Call `getLatestInflationRate()` from `@/lib/api/bls`.
2. Based on result `source`:
   - `"bls_api"` or `"cached"`: Return 200 with `{ data: verified(result.rate, "https://api.bls.gov/publicAPI/v2/timeseries/data/", result.queriedAt!, "BLS CPI-U Annual Rate"), meta: { source: result.source } }`.
   - `"fallback"`: Return 200 with `{ data: estimated(result.rate, "Historical 10-year CPI average"), meta: { source: "fallback" } }`.
3. Wrap in try/catch. On error, return `{ data: estimated(FALLBACK_INFLATION_RATE, "Historical 10-year CPI average"), meta: { source: "error_fallback" } }`.

Import from: `next/server` (NextResponse), `@/lib/api/bls` (getLatestInflationRate, FALLBACK_INFLATION_RATE), `@/lib/engine/verified-datum` (verified, estimated).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify both route files export a `GET` function.
  </verify>
  <done>
GET /api/flights/quote reads from cache, returns VerifiedDatum with "verified" confidence for cached data or "estimated" for static fallback. GET /api/inflation/cpi returns VerifiedDatum from BLS cache or 3.5% fallback. Neither endpoint calls an external API in the request path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cron jobs for flight warming and CPI refresh, plus vercel.json</name>
  <files>src/app/api/cron/warm-flights/route.ts, src/app/api/cron/refresh-cpi/route.ts, vercel.json</files>
  <action>
**Flight warming cron -- `src/app/api/cron/warm-flights/route.ts`:**

Create a GET handler following the existing cron auth pattern from `src/app/api/cron/scrape/route.ts`:
1. **Auth:** Check `request.headers.get("authorization") === Bearer ${process.env.CRON_SECRET}`. If not, return 401.
2. **Build unique airport pairs** from `HUNTING_ROUTES`: deduplicate by `${route.from}:${route.to}` to get unique origin-destination pairs (there are ~48 routes, ~35-40 unique pairs).
3. **Check quota before starting:** Call `checkQuotaRemaining()` from amadeus.ts. If `exhausted`, return 200 with `{ skipped: true, reason: "Quota exhausted", quota }`.
4. **Batch processing:** Process pairs in groups of 10 with a 1-second delay between groups (to stay within Vercel function timeout). For each pair:
   - Generate a search date: use the first day of the next month that falls in hunting season (September-November). If current month is already in Sep-Nov, use 6 weeks from now. Otherwise use October 1 of the current or next year.
   - Call `searchFlightOffers(pair.from, pair.to, searchDate)`.
   - If result returned, cache it: `cacheSet(flight:${pair.from}:${pair.to}, { price: result.price, currency: result.currency, airline: result.airline, queriedAt: result.queriedAt }, "flight_prices")`.
   - Track successes and failures.
5. Return 200 with `{ success: true, cached: successCount, failed: failCount, skipped: skipCount, quota: await checkQuotaRemaining() }`.
6. Export `const maxDuration = 60` for Vercel Pro plan compatibility (if on Hobby, the batching keeps each group under 10s).

Import from: `next/server`, `@/lib/api/amadeus` (searchFlightOffers, checkQuotaRemaining), `@/lib/redis` (cacheSet), `@/lib/constants/flight-hubs` (HUNTING_ROUTES).

**CPI refresh cron -- `src/app/api/cron/refresh-cpi/route.ts`:**

Create a GET handler:
1. **Auth:** Same CRON_SECRET pattern as above.
2. Call `fetchCpiData(currentYear - 1, currentYear)` from bls.ts.
3. If data returned and non-empty, compute rate via `computeAnnualInflationRate(data)`.
4. Cache the result: `cacheSet("bls:cpi_annual_rate", { rate, queriedAt: new Date().toISOString() }, "cpi_data")`.
5. Return 200 with `{ success: true, rate, dataPoints: data.length, queriedAt }`.
6. On failure: return 200 with `{ success: false, error: "Failed to fetch CPI data", fallbackRate: FALLBACK_INFLATION_RATE }`. Do not return 500 -- cron failures should be logged, not alerted.

Import from: `next/server`, `@/lib/api/bls` (fetchCpiData, computeAnnualInflationRate, FALLBACK_INFLATION_RATE), `@/lib/redis` (cacheSet).

**vercel.json update:**

Read existing vercel.json (currently has one cron entry for `/api/cron/scrape`). Add two more cron entries:
- `{ "path": "/api/cron/warm-flights", "schedule": "0 8 1 * *" }` (1st of each month at 8am UTC)
- `{ "path": "/api/cron/refresh-cpi", "schedule": "0 10 15 * *" }` (15th of each month at 10am UTC)

Keep the existing scrape cron entry intact. Final crons array should have 3 entries.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to confirm no type errors.
2. Verify vercel.json is valid JSON with 3 cron entries.
3. Verify both cron files check CRON_SECRET auth header.
4. Verify warm-flights imports from amadeus.ts and flight-hubs.ts.
5. Verify refresh-cpi imports from bls.ts.
  </verify>
  <done>
Two cron endpoints exist with CRON_SECRET auth. warm-flights batches HUNTING_ROUTES pairs through Amadeus with quota awareness and caches results with 6h TTL. refresh-cpi fetches BLS CPI data and caches the computed inflation rate with 30d TTL. vercel.json has all 3 cron entries (scrape weekly, flights monthly 1st, CPI monthly 15th).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. All 4 route files exist and export GET handlers
3. vercel.json has 3 valid cron entries
4. User-facing routes (`/api/flights/quote`, `/api/inflation/cpi`) never import `searchFlightOffers` or `fetchCpiData` -- they only read from cache
5. Cron routes (`/api/cron/warm-flights`, `/api/cron/refresh-cpi`) DO import from the API clients
6. All routes handle errors gracefully (no 500s, always return structured JSON)
</verification>

<success_criteria>
- Two cache-first GET endpoints serve VerifiedDatum-wrapped data from Redis without calling external APIs
- Two cron endpoints warm the cache on schedule with proper auth protection
- vercel.json contains all three cron schedules (scrape, flights, CPI)
- Quota tracking in warm-flights prevents exceeding Amadeus monthly limit
- All routes degrade gracefully to static fallback values on any error
</success_criteria>

<output>
After completion, create `.planning/phases/06-api-integrations/06-02-SUMMARY.md`
</output>
