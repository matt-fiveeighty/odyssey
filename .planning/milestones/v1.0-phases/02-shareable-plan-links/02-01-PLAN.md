---
phase: 02-shareable-plan-links
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/share/route.ts
  - src/components/results/SharedResultsShell.tsx
autonomous: true

must_haves:
  truths:
    - "POST /api/share accepts a StrategicAssessment, stores it in Redis with 90-day TTL, and returns a share URL with expiration date"
    - "POST /api/share returns 429 with Retry-After header when rate limit is exceeded"
    - "POST /api/share returns 503 when Redis is unavailable (not silent failure)"
    - "SharedResultsShell renders a complete read-only view of assessment data without any Zustand store dependency"
    - "SharedResultsShell shows an expiration banner with the date the link expires"
    - "SharedResultsShell includes a 'Create your own plan' CTA linking to /plan-builder"
  artifacts:
    - path: "src/app/api/share/route.ts"
      provides: "POST endpoint for share link creation"
      exports: ["POST"]
    - path: "src/components/results/SharedResultsShell.tsx"
      provides: "Read-only results view without Zustand"
      exports: ["SharedResultsShell"]
  key_links:
    - from: "src/app/api/share/route.ts"
      to: "src/lib/redis.ts"
      via: "cacheSet with share_links TTL"
      pattern: "cacheSet.*share:.*share_links"
    - from: "src/app/api/share/route.ts"
      to: "src/lib/rate-limit.ts"
      via: "limiters.guest() + checkRateLimit()"
      pattern: "limiters\\.guest|checkRateLimit"
---

<objective>
Create the POST /api/share endpoint and SharedResultsShell component -- the two server-side building blocks that the shared page route and share button will depend on.

Purpose: These are the core artifacts for Phase 2. The API endpoint handles token generation, rate limiting, and Redis storage. The SharedResultsShell provides a Zustand-free read-only rendering of any StrategicAssessment.

Output: Working API route + self-contained read-only results component
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-shareable-plan-links/02-RESEARCH.md

@src/lib/redis.ts
@src/lib/rate-limit.ts
@src/lib/types/index.ts
@src/components/results/ResultsShell.tsx
@src/components/results/sections/HeroSummary.tsx
@src/components/results/sections/PortfolioOverview.tsx
@src/components/results/sections/StatePortfolio.tsx
@src/components/results/sections/TimelineRoadmap.tsx
@src/components/results/sections/LogisticsTab.tsx
@src/components/results/sections/YearOneActionPlan.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST /api/share endpoint with Redis storage and rate limiting</name>
  <files>src/app/api/share/route.ts</files>
  <action>
Create `src/app/api/share/route.ts` with a POST handler that:

1. **Rate limiting** (first thing): Call `limiters.guest()` and `checkRateLimit(limiter, identifier)` where identifier is `req.ip ?? req.headers.get("x-forwarded-for") ?? "anonymous"`. On failure, return 429 JSON `{ error: "Too many share link requests. Please try again later." }` with headers `Retry-After` (seconds until reset), `X-RateLimit-Limit`, `X-RateLimit-Remaining`.

2. **Redis availability check**: Call `getRedis()`. If it returns null, return 503 JSON `{ error: "Share service temporarily unavailable" }`. Do NOT silently fail -- SHARE-02 requires explicit failure if Redis is down.

3. **Request validation**: Parse body via `await req.json()` wrapped in try/catch (return 400 on parse failure). Expect `{ assessment: StrategicAssessment }`. Validate `body.assessment` exists and has an `id` property (return 400 if missing).

4. **Token generation**: Use `crypto.randomUUID()` for the share token (SHARE-05). Build the Redis key as `share:${token}`.

5. **Store in Redis**: Call `cacheSet(shareKey, body.assessment, "share_links")` which uses the 90-day TTL from CACHE_TTLS. This creates an immutable snapshot (SHARE-04) -- the stored data is a copy of the assessment at share time.

6. **Build response**: Construct share URL as `${req.nextUrl.origin}/shared/${token}`. Return 201 JSON `{ url: shareUrl, token, expiresAt: ISO string 90 days from now }`.

Import only from: `next/server` (NextRequest, NextResponse), `@/lib/redis` (cacheSet, getRedis, CACHE_TTLS), `@/lib/rate-limit` (limiters, checkRateLimit), `@/lib/types` (StrategicAssessment).

Do NOT add any authentication -- share creation is anonymous per requirements.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the file exports only POST. Verify it imports from redis.ts and rate-limit.ts correctly. Check that 503 is returned when getRedis() returns null (not graceful degradation -- explicit failure for this endpoint).
  </verify>
  <done>POST /api/share compiles, handles rate limiting (429), Redis unavailability (503), bad input (400), and successful share creation (201 with URL + token + expiresAt).</done>
</task>

<task type="auto">
  <name>Task 2: SharedResultsShell read-only component (no Zustand)</name>
  <files>src/components/results/SharedResultsShell.tsx</files>
  <action>
Create `src/components/results/SharedResultsShell.tsx` as a **client component** (`"use client"`) that renders a read-only view of a StrategicAssessment without any Zustand store dependencies.

**Why fork instead of making ResultsShell conditionally read-only:** The existing ResultsShell uses `useWizardStore` and `useAppStore` throughout, and its child section components (HeroSummary, PortfolioOverview, StatePortfolio, YearOneActionPlan) also read from Zustand stores directly. Adding a `readOnly` prop would require threading it through 5+ dynamically imported components. Forking keeps the shared page isolated from future changes to the interactive results flow.

**Component props:**
```typescript
interface SharedResultsShellProps {
  assessment: StrategicAssessment;
  expiresAt: string; // ISO date string of expiration
}
```

**Structure (top to bottom):**

1. **Shared plan banner** -- A top bar showing "Shared Hunt Strategy" with a Clock icon, the expiration date formatted via `new Date(expiresAt).toLocaleDateString("en-US", { month: "long", day: "numeric", year: "numeric" })`, and a "Create your own plan" button (variant="outline", size="sm") linking to `/plan-builder` with an ArrowRight icon.

2. **Hero section** -- Render the profile summary and strategy overview directly from `assessment.profileSummary` and `assessment.strategyOverview`. Show the 4 key stats: states count (`assessment.stateRecommendations.length`), planned hunts (`assessment.macroSummary.plannedHunts`), 10-year total (`assessment.financialSummary.tenYearTotal` formatted as currency), and year-one investment (`assessment.financialSummary.yearOneInvestment` formatted as currency). Do NOT import HeroSummary (it uses useAppStore for milestones we don't have).

3. **State recommendations** -- For each `assessment.stateRecommendations`, render a card showing: state name (from `STATES_MAP`), role badge (primary/secondary/wildcard/long_term), reason text, annual cost, point strategy, and best units with draw timelines. Import `STATES_MAP` from `@/lib/constants/states` and `SpeciesAvatar` from `@/components/shared/SpeciesAvatar`. Use `formatSpeciesName` from `@/lib/utils`.

4. **Roadmap timeline** -- For each `assessment.roadmap` year, show the year number, year type label, estimated cost, and list of actions with type badges (apply/buy_points/hunt/scout), state, species, and cost. This is a read-only version -- no edit/delete buttons, no onEditedActionsChange callback.

5. **Financial summary** -- Show the budget breakdown: annual subscription cost, 10-year total, year-one investment. Use `assessment.financialSummary` and `assessment.budgetBreakdown`.

6. **Bottom CTA** -- Centered section with heading "Ready to build your own strategy?", description "Get a personalized 10-year western big game hunting roadmap in minutes.", and a large "Start Your Plan" button linking to `/plan-builder`.

**Styling:** Match the existing app's Tailwind patterns -- `bg-card`, `border-border`, `text-foreground`, `text-muted-foreground`, `rounded-xl`, `shadow-sm`. Use `space-y-6` for vertical rhythm. Max width `max-w-4xl mx-auto p-6`.

**Icons:** Import from lucide-react: `Clock`, `ArrowRight`, `MapPin`, `Target`, `DollarSign`, `Calendar`.

**Do NOT:**
- Import useWizardStore, useAppStore, or any Zustand store
- Import useRouter or any navigation hooks
- Import ResultsShell or EditableAction
- Import StrategyComparison (not relevant for shared view)
- Add any edit/delete/confirm functionality
- Use dynamic() imports -- this component is simpler and doesn't need code splitting
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Grep for "useWizardStore\|useAppStore\|useRouter" in the file -- must return zero matches. Verify the component exports `SharedResultsShell` and accepts `{ assessment, expiresAt }` props.
  </verify>
  <done>SharedResultsShell renders a complete read-only view of assessment data with expiration banner, hero stats, state recommendations, roadmap timeline, financial summary, and CTA -- all without any Zustand dependency.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `grep -r "useWizardStore\|useAppStore" src/components/results/SharedResultsShell.tsx` returns nothing
- `grep "export async function POST" src/app/api/share/route.ts` confirms route handler exists
- `grep "limiters.guest" src/app/api/share/route.ts` confirms rate limiting is wired
- `grep "getRedis" src/app/api/share/route.ts` confirms Redis availability check exists
- `grep "503" src/app/api/share/route.ts` confirms explicit failure on Redis unavailability
</verification>

<success_criteria>
1. POST /api/share endpoint exists and handles all edge cases (rate limit, no Redis, bad input, success)
2. SharedResultsShell renders assessment data read-only with zero Zustand dependencies
3. Expiration banner and "Create your own plan" CTA are present in SharedResultsShell
4. Both files compile without type errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-shareable-plan-links/02-01-SUMMARY.md`
</output>
