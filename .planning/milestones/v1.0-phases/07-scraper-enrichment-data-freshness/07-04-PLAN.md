---
phase: 07-scraper-enrichment-data-freshness
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/components/shared/FreshnessBadge.tsx
  - src/components/shared/DataSourceBadge.tsx
  - src/lib/engine/data-loader.ts
autonomous: true

must_haves:
  truths:
    - "FreshnessBadge accepts a VerifiedDatum<unknown> and displays a confidence dot (green=verified, blue=user_reported, amber=estimated, red=stale) with text label"
    - "FreshnessBadge shows a provenance tooltip on hover with source URL, scrape date, and confidence explanation"
    - "FreshnessBadge computes staleness on the client only (no server/client hydration flicker)"
    - "DataSourceBadge is extended with a 'Data last updated' timestamp showing absolute date and relative time"
    - "Data loader merges scraped fees and seasons (in addition to existing deadline merging) from Supabase into state constants"
  artifacts:
    - path: "src/components/shared/FreshnessBadge.tsx"
      provides: "VerifiedDatum-aware freshness indicator with provenance tooltip"
      exports: ["FreshnessBadge"]
    - path: "src/components/shared/DataSourceBadge.tsx"
      provides: "Enhanced state-level data source badge with 'Data last updated' timestamp"
      exports: ["DataSourceBadge", "DataSourceInline"]
    - path: "src/lib/engine/data-loader.ts"
      provides: "Extended three-tier data loader merging fees and seasons alongside deadlines"
      exports: ["loadDataContext", "refreshDataContext", "getDataStatus"]
  key_links:
    - from: "src/components/shared/FreshnessBadge.tsx"
      to: "src/lib/engine/verified-datum.ts"
      via: "Imports VerifiedDatum type and DataConfidence for rendering"
      pattern: "import.*VerifiedDatum|import.*DataConfidence"
    - from: "src/lib/engine/data-loader.ts"
      to: "@supabase/supabase-js"
      via: "Queries scraped_fees and scraped_seasons tables alongside existing scraped_deadlines"
      pattern: "scraped_fees|scraped_seasons"
---

<objective>
Build the FreshnessBadge component for datum-level provenance display, enhance DataSourceBadge with a "Data last updated" timestamp, and extend the data loader to merge scraped fees and seasons into state constants.

Purpose: FreshnessBadge is the user-facing trust signal that makes data provenance visible -- every number can show whether it is verified, estimated, or stale. The data-loader extension ensures that scraped fee and season data actually flows into the UI (currently only deadlines are merged). DataSourceBadge enhancement surfaces the "last updated" timestamp on the dashboard for FRESH-04.

Output: `FreshnessBadge.tsx` component, enhanced `DataSourceBadge.tsx`, and extended `data-loader.ts` with fee/season merging.
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/engine/verified-datum.ts
@src/components/shared/DataSourceBadge.tsx
@src/lib/engine/data-loader.ts
@src/lib/types/index.ts
@.planning/phases/07-scraper-enrichment-data-freshness/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FreshnessBadge component with provenance tooltip</name>
  <files>src/components/shared/FreshnessBadge.tsx</files>
  <action>
Create `src/components/shared/FreshnessBadge.tsx` as a client component ("use client").

**Props interface:**
```typescript
interface FreshnessBadgeProps {
  datum: VerifiedDatum<unknown>;
  /** Optional: show inline text label (default true) */
  showLabel?: boolean;
  className?: string;
}
```

**Confidence color mapping:**
```typescript
const CONFIDENCE_COLORS: Record<DataConfidence, string> = {
  verified: "bg-emerald-500",
  user_reported: "bg-blue-500",
  estimated: "bg-amber-500",
  stale: "bg-red-500",
};

const CONFIDENCE_LABELS: Record<DataConfidence, string> = {
  verified: "Verified",
  user_reported: "User Reported",
  estimated: "Estimated",
  stale: "Stale",
};

const CONFIDENCE_DESCRIPTIONS: Record<DataConfidence, string> = {
  verified: "Scraped directly from state Fish & Game website",
  user_reported: "Reported by a user and awaiting verification",
  estimated: "Estimated based on historical data and heuristics",
  stale: "Data is older than expected â€” may be outdated",
};
```

**Component logic:**
1. Compute the effective confidence: if `datum.isStale`, override to `"stale"` regardless of `datum.confidence`.
2. Compute relative time from `datum.source.scrapedAt` using client-side `Date.now()` to avoid hydration flicker. Use a `useState` + `useEffect` pattern:
   ```typescript
   const [relativeTime, setRelativeTime] = useState<string>("");

   useEffect(() => {
     if (!datum.source.scrapedAt) {
       setRelativeTime("No date available");
       return;
     }
     const days = Math.floor((Date.now() - new Date(datum.source.scrapedAt).getTime()) / (1000 * 60 * 60 * 24));
     if (days === 0) setRelativeTime("Today");
     else if (days === 1) setRelativeTime("Yesterday");
     else if (days < 30) setRelativeTime(`${days} days ago`);
     else if (days < 365) setRelativeTime(`${Math.floor(days / 30)} months ago`);
     else setRelativeTime(`${Math.floor(days / 365)} years ago`);
   }, [datum.source.scrapedAt]);
   ```

3. **Render structure:**
   - A `<span>` wrapper with `group relative inline-flex items-center gap-1`.
   - A colored dot: `<span className="w-1.5 h-1.5 rounded-full {CONFIDENCE_COLORS[effective]}" />`.
   - If `showLabel !== false`: `<span className="text-[9px] text-muted-foreground/60">{CONFIDENCE_LABELS[effective]}</span>`.
   - A tooltip div that appears on hover (`group-hover:opacity-100 group-hover:visible`):
     ```
     <div className="absolute bottom-full left-0 mb-1 w-56 rounded-md bg-popover/95 backdrop-blur-sm border border-border p-2.5 text-[10px] shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-opacity z-50">
       <div className="font-medium text-foreground">{CONFIDENCE_LABELS[effective]}</div>
       <div className="text-muted-foreground mt-0.5">{CONFIDENCE_DESCRIPTIONS[effective]}</div>
       {datum.source.url && (
         <div className="mt-1.5 text-muted-foreground/80">
           <span className="font-medium">Source:</span> {datum.source.label}
         </div>
       )}
       {datum.source.scrapedAt && (
         <div className="text-muted-foreground/80">
           <span className="font-medium">Updated:</span> {relativeTime}
         </div>
       )}
       {datum.source.url && (
         <a href={datum.source.url} target="_blank" rel="noopener noreferrer" className="mt-1 inline-block text-primary/60 hover:text-primary underline-offset-2 hover:underline">
           View source
         </a>
       )}
     </div>
     ```

**Important:**
- Use "use client" directive (matches DataSourceBadge pattern).
- Compute freshness purely on the client side via useEffect to avoid server/client hydration mismatch (Pitfall 6 from research).
- Import types from `@/lib/engine/verified-datum` (VerifiedDatum, DataConfidence).
- Do NOT import STALE_THRESHOLDS -- the `isStale` flag is already computed on the datum.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the file exports FreshnessBadge. Verify "use client" is the first line. Verify imports from verified-datum.ts for VerifiedDatum and DataConfidence types.
  </verify>
  <done>
FreshnessBadge component renders a confidence dot (green/blue/amber/red) with optional text label and a hover tooltip showing confidence explanation, source label, relative update time, and a "View source" link. Staleness is computed client-side only via useEffect. Exports FreshnessBadge from a "use client" module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance DataSourceBadge with "Data last updated" timestamp, and extend data-loader to merge fees and seasons</name>
  <files>src/components/shared/DataSourceBadge.tsx, src/lib/engine/data-loader.ts</files>
  <action>
**Part A: Enhance DataSourceBadge with "Data last updated" display.**

Add a `showLastUpdated` prop to `DataSourceBadgeProps`:
```typescript
interface DataSourceBadgeProps {
  stateId: string;
  dataType?: string;
  /** Show "Data last updated: {timestamp}" below the badge (default false) */
  showLastUpdated?: boolean;
  className?: string;
}
```

When `showLastUpdated` is true, add a second line below the existing badge content:
```typescript
{showLastUpdated && lastScraped && (
  <div className="text-[8px] text-muted-foreground/40 mt-0.5">
    Data last updated: {lastScraped}
  </div>
)}
```

Also add a relative time indicator. Compute relative time client-side:
```typescript
const [relativeTime, setRelativeTime] = useState<string>("");
useEffect(() => {
  if (!state.lastScrapedAt) return;
  const days = Math.floor((Date.now() - new Date(state.lastScrapedAt).getTime()) / (1000 * 60 * 60 * 24));
  if (days === 0) setRelativeTime("(today)");
  else if (days === 1) setRelativeTime("(yesterday)");
  else if (days < 30) setRelativeTime(`(${days}d ago)`);
  else setRelativeTime(`(${Math.floor(days / 30)}mo ago)`);
}, [state.lastScrapedAt]);
```

Display as: `Data last updated: Feb 20, 2026 (2d ago)`.

Add an `import { useState, useEffect } from "react"` at the top (the file already has "use client").

**Part B: Extend data-loader to merge scraped fees and seasons.**

Currently `_tryLoadFromSupabase()` and `_tryLoadFromCache()` only fetch and merge deadlines. Extend to also fetch fees and seasons.

1. **Add cache keys:**
```typescript
const CACHE_KEY_FEES = "data:fees:latest";
const CACHE_KEY_SEASONS = "data:seasons:latest";
```

2. **In `_tryLoadFromSupabase()`**, after fetching deadlines, add:
```typescript
// --- Fetch scraped fees for merging into state data ---
const { data: dbFees } = await supabase
  .from("scraped_fees")
  .select("*")
  .limit(2000);

// --- Fetch scraped seasons for current + next year ---
const { data: dbSeasons } = await supabase
  .from("scraped_seasons")
  .select("*")
  .in("year", [currentYear, currentYear + 1])
  .limit(3000);
```

3. **Add mergeFees() function** (similar to mergeDeadlines):
```typescript
interface DbFee {
  state_id: string;
  fee_name: string;
  amount: number;
  residency: string;
  species_id: string | null;
  frequency: string;
  notes: string | null;
}

function mergeFees(states: State[], dbFees: DbFee[]): State[] {
  if (dbFees.length === 0) return states;

  // Group fees by state
  const byState = new Map<string, DbFee[]>();
  for (const f of dbFees) {
    if (!byState.has(f.state_id)) byState.set(f.state_id, []);
    byState.get(f.state_id)!.push(f);
  }

  return states.map((state) => {
    const stateFees = byState.get(state.id);
    if (!stateFees) return state;

    // Build updated tagCosts and licenseFees from scraped data
    const updatedTagCosts = { ...state.tagCosts };
    const updatedLicenseFees = { ...state.licenseFees };

    for (const fee of stateFees) {
      if (fee.species_id && (fee.residency === "nonresident" || fee.residency === "both")) {
        updatedTagCosts[fee.species_id] = fee.amount;
      }
      // Update license-level fees
      const nameLower = fee.fee_name.toLowerCase();
      if (nameLower.match(/app(lication)?\s*(fee|cost)/)) {
        updatedLicenseFees.appFee = fee.amount;
      } else if (nameLower.match(/point\s*(fee|cost)|preference\s*(fee|cost)/)) {
        updatedLicenseFees.pointFee = fee.amount;
      } else if (nameLower.match(/license|qualifying|sportsman|conservation/)) {
        updatedLicenseFees.qualifyingLicense = fee.amount;
      }
    }

    return { ...state, tagCosts: updatedTagCosts, licenseFees: updatedLicenseFees };
  });
}
```

Note: Check the actual State type in `src/lib/types/index.ts` for the exact property names for tag costs and license fees. The merge function should match the existing State type structure. If the State type uses different property names (e.g., `costs` instead of `tagCosts`), adapt accordingly.

4. **Add mergeSeasons() function:**
```typescript
interface DbSeason {
  state_id: string;
  species_id: string;
  unit_code: string | null;
  season_type: string;
  start_date: string;
  end_date: string;
  year: number;
  notes: string | null;
}

function mergeSeasons(states: State[], dbSeasons: DbSeason[]): State[] {
  if (dbSeasons.length === 0) return states;

  // Group by state
  const byState = new Map<string, DbSeason[]>();
  for (const s of dbSeasons) {
    if (!byState.has(s.state_id)) byState.set(s.state_id, []);
    byState.get(s.state_id)!.push(s);
  }

  return states.map((state) => {
    const stateSeasons = byState.get(state.id);
    if (!stateSeasons) return state;

    // Merge season dates into state's seasonDates structure
    // Check State type for exact season data structure and merge accordingly
    const updatedSeasonDates = { ...(state.seasonDates ?? {}) };

    for (const s of stateSeasons) {
      const key = `${s.species_id}:${s.season_type}`;
      updatedSeasonDates[key] = { start: s.start_date, end: s.end_date };
    }

    return { ...state, seasonDates: updatedSeasonDates };
  });
}
```

Note: Again, check the State type for exact property names and merge accordingly.

5. **Wire into `_tryLoadFromSupabase()` and `_tryLoadFromCache()`:**
```typescript
// In _tryLoadFromSupabase():
const mergedStatesWithFees = mergeFees(mergedStates, dbFees ?? []);
const mergedStatesWithSeasons = mergeSeasons(mergedStatesWithFees, dbSeasons ?? []);
// Use mergedStatesWithSeasons as final states

// Cache the new data
cacheSet(CACHE_KEY_FEES, dbFees ?? [], CACHE_KEY_TTL).catch(() => {});
cacheSet(CACHE_KEY_SEASONS, dbSeasons ?? [], CACHE_KEY_TTL).catch(() => {});

// In _tryLoadFromCache():
const cachedFees = await cacheGet<DbFee[]>(CACHE_KEY_FEES);
const cachedSeasons = await cacheGet<DbSeason[]>(CACHE_KEY_SEASONS);
// Merge into states
```

6. **Update DataStatus** to include fee and season counts:
```typescript
// Add to DataStatus interface:
dbFeeCount: number;
dbSeasonCount: number;
```

Track these in the module-level variables and return in `getDataStatus()`.

**Important:** Read `src/lib/types/index.ts` first to understand the exact State type structure before implementing the merge functions. The property names must match exactly.
  </action>
  <verify>
1. `npx tsc --noEmit` to confirm no type errors.
2. FreshnessBadge.tsx exists and exports FreshnessBadge.
3. DataSourceBadge.tsx accepts showLastUpdated prop.
4. data-loader.ts fetches from scraped_fees and scraped_seasons tables.
5. data-loader.ts has mergeFees() and mergeSeasons() functions.
6. getDataStatus() returns dbFeeCount and dbSeasonCount.
  </verify>
  <done>
FreshnessBadge renders VerifiedDatum confidence with hover tooltip showing source and timestamp. DataSourceBadge shows "Data last updated: {date} ({relative})" when showLastUpdated=true. Data loader fetches scraped fees and seasons from Supabase, merges into State constants (alongside existing deadline merging), and caches to Redis. getDataStatus() reports fee and season counts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. FreshnessBadge.tsx is a "use client" component importing from verified-datum.ts
3. FreshnessBadge shows tooltip on hover with source URL, scrape date, and confidence
4. DataSourceBadge accepts showLastUpdated prop and renders timestamp when true
5. data-loader.ts queries scraped_fees and scraped_seasons (not just scraped_deadlines)
6. data-loader.ts has mergeFees and mergeSeasons functions wired into both Tier 1 and Tier 2 paths
7. No hydration mismatches: all Date.now() comparisons happen in useEffect
</verification>

<success_criteria>
- FreshnessBadge displays verified/estimated/stale confidence with provenance tooltip on hover (FRESH-01, FRESH-02)
- DataSourceBadge shows "Data last updated" timestamp with relative time (FRESH-04)
- Data loader merges scraped fees and seasons into state constants, completing the pipeline from scraper -> DB -> UI
- All freshness computations happen client-side to prevent hydration flicker
</success_criteria>

<output>
After completion, create `.planning/phases/07-scraper-enrichment-data-freshness/07-04-SUMMARY.md`
</output>
