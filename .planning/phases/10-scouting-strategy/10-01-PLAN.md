---
phase: 10-scouting-strategy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/types/index.ts
  - src/lib/constants/unit-centroids.ts
  - src/lib/engine/scouting-engine.ts
autonomous: true

must_haves:
  truths:
    - "Engine detects OTC/high-odds units near the user's trophy draw units as scouting opportunities"
    - "Scouting opportunities are scored by geographic proximity, terrain similarity, season overlap, and cost"
    - "Scouting is suppressed for all-OTC portfolios (no multi-year builds = no scouting value)"
    - "Units without centroid data fall back to state-level proximity instead of failing"
  artifacts:
    - path: "src/lib/constants/unit-centroids.ts"
      provides: "Static lat/lon lookup for ~60 units + haversineDistance function"
      contains: "UNIT_CENTROIDS"
    - path: "src/lib/engine/scouting-engine.ts"
      provides: "detectScoutingOpportunities pure function returning ScoutingOpportunity[]"
      exports: ["detectScoutingOpportunities", "ScoutingOpportunity"]
    - path: "src/lib/types/index.ts"
      provides: "ScoutingTarget type for CalendarSlotData extension, scouting category on AdvisorInsightCategory"
      contains: "scouting"
  key_links:
    - from: "src/lib/engine/scouting-engine.ts"
      to: "src/lib/constants/unit-centroids.ts"
      via: "import UNIT_CENTROIDS, haversineDistance"
      pattern: "UNIT_CENTROIDS\\[.*\\]"
    - from: "src/lib/engine/scouting-engine.ts"
      to: "src/lib/constants/sample-units.ts"
      via: "import SAMPLE_UNITS"
      pattern: "SAMPLE_UNITS"
    - from: "src/lib/engine/scouting-engine.ts"
      to: "src/lib/types/index.ts"
      via: "ScoutingOpportunity type"
      pattern: "ScoutingOpportunity"
---

<objective>
Build the scouting opportunity detection engine: a static unit centroid lookup table for geographic distance calculation, and a pure-function scouting scorer that identifies OTC/high-odds units near the user's trophy draw targets.

Purpose: This is the intelligence layer that enables all downstream UI (cards, calendar badges, advisor insights). Without scored scouting opportunities, there's nothing to display.

Output: `unit-centroids.ts` with ~60 unit coordinates + haversine distance, `scouting-engine.ts` with `detectScoutingOpportunities()` returning scored `ScoutingOpportunity[]`, type additions to `types/index.ts`.
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-scouting-strategy/10-RESEARCH.md
@src/lib/types/index.ts
@src/lib/constants/sample-units.ts
@src/lib/engine/opportunity-scorer.ts
@src/lib/engine/roadmap-generator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit centroid lookup + haversine distance + type additions</name>
  <files>
    src/lib/constants/unit-centroids.ts
    src/lib/types/index.ts
  </files>
  <action>
**unit-centroids.ts:**

Create a static lookup table `UNIT_CENTROIDS: Record<string, [number, number]>` mapping every unit ID from `sample-units.ts` to approximate [lat, lon] coordinates. Use the unit names, state context, and nearest airport info to determine reasonable centroids. ~60 entries organized by state.

Reference coordinates for major areas:
- CO NW (Meeker/White River area): ~39.9, -107.9
- CO Gunnison: ~38.5, -106.9
- CO San Juan: ~37.8, -107.7
- WY Bighorns: ~44.5, -107.2
- WY Wind River: ~42.8, -109.2
- WY desert: ~41.8, -108.8
- MT western: ~46.5, -113.5
- MT eastern: ~47.0, -108.0
- AZ Kaibab: ~36.5, -112.1
- AZ SE: ~32.5, -110.0
- NV central: ~40.0, -117.0
- UT: ~39.5, -111.5
- NM: ~35.0, -108.5
- OR: ~44.0, -121.0
- ID: ~44.5, -114.5
- KS: ~39.0, -99.0
- AK: ~62.0, -150.0

Export `haversineDistance([lat1, lon1], [lat2, lon2])` returning distance in miles. Use Earth radius = 3959 miles. Standard formula (~10 lines).

Export a helper `getUnitDistance(unitIdA: string, unitIdB: string, stateIdA: string, stateIdB: string)` that:
1. Looks up both centroids in UNIT_CENTROIDS
2. If both found, returns `{ distanceMiles: number, source: "centroid" }`
3. If either missing, falls back to state-level proximity using a region map (same logic as the private `getStateDistance()` in roadmap-generator.ts -- duplicate the region mapping since it's not exported). Returns `{ distanceMiles: null, source: "state_region", proximity: "close" | "medium" | "far" }`

**types/index.ts:**

1. Add `"scouting"` to the `AdvisorInsightCategory` union type (after "savings").

2. Add `ScoutingTarget` interface (used by CalendarSlotData and ScoutingMoveCard):
```typescript
export interface ScoutingTarget {
  targetStateId: string;
  targetSpeciesId: string;
  targetUnitCode: string;
  targetYearsAway: number;
  strategicReason: string;
}
```

3. Add optional `scoutingTarget?: ScoutingTarget` field to `CalendarSlotData` in calendar-grid.ts (NOT types/index.ts -- CalendarSlotData lives in calendar-grid.ts). Actually, `CalendarSlotData` is defined in `src/lib/engine/calendar-grid.ts`. So add `ScoutingTarget` to types/index.ts and then Task 2 or Plan 02 will add the field to CalendarSlotData. For now, just define the type in types/index.ts.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. Verify UNIT_CENTROIDS has entries for all unit IDs in sample-units.ts by comparing: `grep "id:" src/lib/constants/sample-units.ts | wc -l` should roughly match `Object.keys(UNIT_CENTROIDS).length` count.
  </verify>
  <done>
    UNIT_CENTROIDS has a [lat, lon] entry for every unit in sample-units.ts. haversineDistance computes correct distances (e.g., Denver to Meeker ~180 miles). getUnitDistance falls back to region-based proximity when centroids missing. ScoutingTarget type and "scouting" category are defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scouting opportunity detection engine</name>
  <files>
    src/lib/engine/scouting-engine.ts
  </files>
  <action>
Create `scouting-engine.ts` as a pure-function module following the same patterns as `opportunity-scorer.ts`.

**ScoutingOpportunity interface** (export):
```typescript
export interface ScoutingOpportunity {
  scoutUnit: Unit;
  scoutUnitId: string;
  targetUnit: { unitCode: string; unitName: string; stateId: string; speciesId: string };
  targetYearsAway: number;
  proximityScore: number;     // 0-40
  terrainScore: number;       // 0-25
  seasonScore: number;        // 0-20
  costScore: number;          // 0-15
  totalScore: number;         // 0-100
  distanceMiles: number | null;
  terrainOverlap: string[];
  strategicReason: string;
}
```

**Main function: `detectScoutingOpportunities(assessment: StrategicAssessment): ScoutingOpportunity[]`**

Logic:
1. **Extract trophy targets:** From `assessment.stateRecommendations`, find bestUnits where the user needs 2+ years to draw (use `pointsRequiredNonresident` from matching SAMPLE_UNITS entry, compared against user points from assessment context). A unit qualifies as a "trophy target" if it requires multi-year point building (`pointsRequiredNonresident >= 2`).

2. **Suppress for all-OTC portfolios:** If NO trophy targets exist (all units are OTC/zero-point), return empty array. This prevents recommending scouting when there's nothing to scout for.

3. **Build scouting candidate pool:** From `SAMPLE_UNITS`, filter units that:
   - `pointsRequiredNonresident <= 1` (accessible now or next year)
   - `tagQuotaNonresident >= 50` (reasonable tag supply)
   - `successRate >= 0.15` (scouting hunts should produce encounters)
   - Are NOT already one of the user's trophy targets or recommended units

4. **Score each candidate against each trophy target:**

   **Proximity (0-40):** Use `getUnitDistance()` from unit-centroids.ts.
   - Centroid-based: 0-50 mi = 40, 50-100 = 30, 100-200 = 20, 200-400 = 10, 400+ = 5
   - State fallback: close = 25, medium = 15, far = 5
   - Same-state novelty discount: if scouting unit is in the same state as trophy target, reduce by 30% (round). Cross-state scouting is more valuable.

   **Terrain (0-25):** Jaccard similarity on `terrainType[]` arrays, scaled to 25.
   - `overlap = scoutTerrain.filter(t => targetTerrain.includes(t))`
   - `union = new Set([...scoutTerrain, ...targetTerrain]).size`
   - Score = `Math.round((overlap.length / union) * 25)` (0 union = 12 neutral)
   - Cross-species discount: if scout.speciesId !== target.speciesId, reduce terrain score by 20% (different species use terrain differently)

   **Season (0-20):** Compare `tacticalNotes.bestSeasonTier` and `tacticalNotes.bestArrivalDate`.
   - Same season tier keyword match (both "Rifle", both "Archery") = 20
   - Same arrival month = 20, adjacent month = 12, else = 8
   - No tactical notes = 8 (neutral)

   **Cost (0-15):** Based on the scout unit's tag cost (look up from STATES via `tagCosts[speciesId]`).
   - <= $200 = 15, $200-$500 = 10, $500-$1000 = 7, $1000+ = 3

   **Total:** Sum all four scores.

5. **Filter and cap:**
   - Minimum total score threshold: 45 (below this, the match is too weak to recommend)
   - For each trophy target, keep top 2 scouting candidates
   - Overall cap: 5 scouting opportunities per assessment
   - Sort by totalScore descending

6. **Generate strategicReason:** Build a data-grounded string:
   - Include terrain overlap: "Similar terrain (Sagebrush, Timber)"
   - Include elevation comparison: "at comparable elevation (6,000-9,500 ft)"
   - Include distance if available: "~85 miles from your trophy unit"
   - Use tacticalNotes if available for ecological color
   - NEVER claim wildlife biology knowledge we don't have (no "same migration corridor" unless tacticalNotes explicitly mention it)

Import from: `@/lib/types` (StrategicAssessment, Unit, ScoutingTarget), `@/lib/constants/sample-units` (SAMPLE_UNITS), `@/lib/constants/unit-centroids` (getUnitDistance, UNIT_CENTROIDS), `@/lib/constants/states` (STATES_MAP).
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no type errors. The function should be importable and callable with a StrategicAssessment. Verify the module exports `detectScoutingOpportunities` and `ScoutingOpportunity`.
  </verify>
  <done>
    `detectScoutingOpportunities(assessment)` returns scored `ScoutingOpportunity[]` with proximity, terrain, season, and cost breakdowns. Trophy target detection works. All-OTC portfolios return empty. Candidates are filtered, scored, and capped. Strategic reasons are data-grounded.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `UNIT_CENTROIDS` covers all units in `SAMPLE_UNITS`
3. `haversineDistance` returns reasonable values (Denver-area to Meeker-area ~180 mi)
4. `detectScoutingOpportunities` returns empty for an assessment with no multi-year draw targets
5. `detectScoutingOpportunities` returns scored opportunities for an assessment with trophy targets 3+ years away
6. No scouting opportunities recommend a unit already in the user's plan
</verification>

<success_criteria>
- Unit centroid lookup has entries for all ~60 sample units
- Haversine distance function computes correct mile distances
- Scouting engine scores candidates on 4 dimensions (proximity, terrain, season, cost)
- All-OTC portfolios produce zero scouting recommendations
- Minimum score threshold and per-target/global caps prevent over-recommendation
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/10-scouting-strategy/10-01-SUMMARY.md`
</output>
