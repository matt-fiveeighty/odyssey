---
phase: 08-savings-budget-tracker
plan: 02
type: tdd
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/lib/engine/savings-calculator.ts
  - src/lib/engine/__tests__/savings-calculator.test.ts
autonomous: true
must_haves:
  truths:
    - "Monthly savings target correctly divides remaining cost by months remaining"
    - "Funded date projection returns the month when savings will equal target cost"
    - "Traffic light status returns green/amber/red based on funded date vs target date"
    - "Edge cases (zero monthly, past target date, already funded) return sensible values, never NaN or Infinity"
    - "Annual spend forecast groups milestone costs by year"
  artifacts:
    - path: "src/lib/engine/savings-calculator.ts"
      provides: "Pure savings math functions"
      exports: ["calculateMonthlySavingsTarget", "calculateFundedDate", "calculateSavingsStatus", "calculateCatchUpDelta", "deriveTargetCost", "calculateAnnualSpendForecast"]
    - path: "src/lib/engine/__tests__/savings-calculator.test.ts"
      provides: "Comprehensive test coverage for all calculator functions"
      contains: "describe"
  key_links:
    - from: "src/lib/engine/savings-calculator.ts"
      to: "src/lib/types/index.ts"
      via: "import SavingsStatus, Milestone, UserGoal types"
      pattern: "import.*from.*types"
---

<objective>
Build the pure-function savings calculator engine with TDD.

Purpose: All savings math (monthly targets, funded-date projections, traffic light status, catch-up deltas, target cost derivation, annual spend forecasts) lives in one testable module. This engine has no React, no store access, no side effects. It's the arithmetic brain that the UI components and advisor consume.

Output: src/lib/engine/savings-calculator.ts with 6 exported functions and comprehensive test coverage.
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-savings-budget-tracker/08-RESEARCH.md
@src/lib/types/index.ts
</context>

<feature>
  <name>Savings Calculator Engine</name>
  <files>src/lib/engine/savings-calculator.ts, src/lib/engine/__tests__/savings-calculator.test.ts</files>
  <behavior>
Six pure functions with defined I/O:

1. calculateMonthlySavingsTarget(targetCost, targetDate, currentSaved, now?) -> number
   - (5000, "2027-09-01", 1000, "2026-03-01") -> ~222 (4000 / 18 months)
   - (5000, "2026-03-15", 5000, "2026-03-01") -> 0 (already funded)
   - (5000, "2026-03-01", 0, "2026-03-01") -> 5000 (target date is now, Math.max(1, months))

2. calculateFundedDate(targetCost, currentSaved, monthlySavings, now?) -> Date | null
   - (5000, 1000, 200, "2026-03-01") -> ~2027-11-01 (20 months from now)
   - (5000, 5000, 200, "2026-03-01") -> 2026-03-01 (already funded, returns now)
   - (5000, 0, 0, "2026-03-01") -> null (never funded)

3. calculateSavingsStatus(targetCost, currentSaved, monthlySavings, targetDate, now?) -> SavingsStatus
   - funded date <= target date -> "green"
   - funded date 1-3 months after target -> "amber"
   - funded date >3 months after target OR monthlySavings=0 -> "red"
   - currentSaved >= targetCost -> "green" (regardless of other params)

4. calculateCatchUpDelta(targetCost, currentSaved, currentMonthlySavings, targetDate, now?) -> number
   - Returns extra monthly amount needed: max(0, neededTarget - currentMonthlySavings)
   - Already on track -> 0
   - Behind by $50/mo -> 50

5. deriveTargetCost(milestones, goalId) -> number
   - Sums totalCost of milestones where planId === goalId
   - No milestones -> 0

6. calculateAnnualSpendForecast(userGoals, milestones, yearsAhead?) -> AnnualSpendForecast[]
   - Groups incomplete milestones by year
   - Returns { year, items[], totalCost } for each of next N years (default 5)
  </behavior>
  <implementation>
Follow the research code examples closely. Key implementation details:

- All date parameters accept Date objects. The `now` parameter defaults to `new Date()` for production but is injectable for testing.
- Use `Math.max(1, monthsRemaining)` to prevent division by zero.
- Months remaining calculation: `msRemaining / (1000 * 60 * 60 * 24 * 30.44)` for average month length.
- `calculateFundedDate` uses `Math.ceil(remaining / monthlySavings)` then `setMonth(getMonth() + monthsNeeded)`.
- Traffic light thresholds: green = on time, amber = 1-3 months late, red = >3 months late or $0/mo.
- `deriveTargetCost` filters by `m.planId === goalId` (matching the existing milestone planId field).
- `AnnualSpendForecast` interface exported alongside the function.
- Export all functions as named exports.

Edge cases to test:
- targetCost = 0
- currentSaved > targetCost (overfunded)
- monthlySavings = 0
- targetDate in the past
- No milestones for a goalId
- Year with no milestones (empty items array, totalCost = 0)
  </implementation>
</feature>

<verification>
1. `npx vitest run src/lib/engine/__tests__/savings-calculator.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. No NaN or Infinity in any edge case test
</verification>

<success_criteria>
- All 6 functions exported and tested
- Edge cases (zero, negative, already funded, never funded) produce sensible numeric values
- No external dependencies beyond types
- RED-GREEN-REFACTOR commits for each function
</success_criteria>

<output>
After completion, create `.planning/phases/08-savings-budget-tracker/08-02-SUMMARY.md`
</output>
