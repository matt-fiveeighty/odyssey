---
phase: 04-calendar-subscription
plan: 02
type: execute
wave: 2
depends_on: [1]
files_modified:
  - src/app/api/cal/route.ts
  - src/app/api/cal/[token]/route.ts
  - src/components/results/SubscribeCalendar.tsx
  - src/components/results/ResultsShell.tsx
  - src/middleware.ts
autonomous: false

must_haves:
  truths:
    - "POST /api/cal stores plan snapshot in Redis with 365d TTL and returns token, webcal URL, and HTTP URL"
    - "GET /api/cal/[token] retrieves plan snapshot from Redis, generates ICS dynamically via buildICS, and returns text/calendar response"
    - "webcal:// URL opens native calendar app (Google Calendar, Apple Calendar) for subscription"
    - "User can regenerate calendar token from UI, which creates a new snapshot without invalidating old tokens (ICS-08)"
    - "Calendar subscription works independently of browser state -- purely server-side via Redis snapshot (ICS-05)"
    - "Middleware excludes /api/cal routes from auth processing"
    - "User sees Subscribe to Calendar button in results, with copy-URL and open-in-calendar options"
  artifacts:
    - path: "src/app/api/cal/route.ts"
      provides: "POST endpoint for creating calendar subscription tokens"
      exports: ["POST"]
    - path: "src/app/api/cal/[token]/route.ts"
      provides: "GET endpoint serving ICS calendar feed from Redis snapshot"
      exports: ["GET"]
    - path: "src/components/results/SubscribeCalendar.tsx"
      provides: "Subscribe to Calendar button with token management UI"
      exports: ["SubscribeCalendar"]
    - path: "src/components/results/ResultsShell.tsx"
      provides: "Modified results shell including SubscribeCalendar button"
      exports: ["ResultsShell"]
    - path: "src/middleware.ts"
      provides: "Updated middleware excluding /api/cal from auth"
      exports: ["middleware", "config"]
  key_links:
    - from: "src/app/api/cal/route.ts"
      to: "src/lib/redis.ts"
      via: "cacheSet with calendar_plans TTL for plan snapshot storage"
      pattern: "cacheSet.*calendar_plans"
    - from: "src/app/api/cal/[token]/route.ts"
      to: "src/lib/calendar/ics-builder.ts"
      via: "buildICS + buildCalendarEventsFromGrid to generate ICS from snapshot"
      pattern: "import.*buildICS.*from.*calendar/ics-builder"
    - from: "src/app/api/cal/[token]/route.ts"
      to: "src/lib/engine/calendar-grid.ts"
      via: "buildCalendarGrid to convert assessment into calendar data"
      pattern: "import.*buildCalendarGrid.*from.*calendar-grid"
    - from: "src/components/results/SubscribeCalendar.tsx"
      to: "src/app/api/cal/route.ts"
      via: "fetch POST /api/cal to create subscription"
      pattern: "fetch.*api/cal"
    - from: "src/components/results/ResultsShell.tsx"
      to: "src/components/results/SubscribeCalendar.tsx"
      via: "renders SubscribeCalendar in action button row"
      pattern: "import.*SubscribeCalendar"
---

<objective>
Create the calendar subscription endpoint (POST to create, GET to serve), the SubscribeCalendar UI component, and integrate into ResultsShell. This delivers the complete user-facing calendar subscription flow: click Subscribe, get a webcal:// URL, add to Google Calendar or Apple Calendar, and receive automatic updates via server-side ICS generation from Redis snapshots.

Purpose: This plan connects the isomorphic ICS builder (Plan 01) to the user via API endpoints and UI. It follows the proven share link pattern (POST creates token + Redis snapshot, GET serves content) but serves dynamic ICS content instead of a page. Requirements ICS-02, ICS-03, ICS-05, ICS-08 are addressed here.

Output: Two API routes (`POST /api/cal`, `GET /api/cal/[token]`), one client component (`SubscribeCalendar.tsx`), and modifications to `ResultsShell.tsx` and `middleware.ts`.
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-calendar-subscription/04-RESEARCH.md
@.planning/phases/04-calendar-subscription/04-01-SUMMARY.md

@src/app/api/share/route.ts
@src/lib/redis.ts
@src/lib/rate-limit.ts
@src/lib/calendar/ics-builder.ts
@src/lib/calendar/uid-generator.ts
@src/lib/engine/calendar-grid.ts
@src/lib/types/index.ts
@src/lib/constants/states.ts
@src/components/results/ResultsShell.tsx
@src/components/results/ShareButton.tsx
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST /api/cal and GET /api/cal/[token] endpoints + middleware update</name>
  <files>
    src/app/api/cal/route.ts
    src/app/api/cal/[token]/route.ts
    src/middleware.ts
  </files>
  <action>
**Step 1: Create `src/app/api/cal/route.ts` -- POST endpoint for subscription creation**

Follow the exact pattern from `src/app/api/share/route.ts` with these differences:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { cacheSet, isCacheAvailable, CACHE_TTLS } from "@/lib/redis";
import { limiters, checkRateLimit } from "@/lib/rate-limit";
import type { StrategicAssessment } from "@/lib/types";
```

Implementation:

1. **Rate limiting** (copy share pattern): Use `limiters.guest()` with x-forwarded-for identifier. Return 429 with Retry-After header on rate limit hit.

2. **Cache availability check**: If `!isCacheAvailable()`, return 503 `{ error: "Calendar service temporarily unavailable" }`.

3. **Request validation**: Parse JSON body. Expect `{ assessment: StrategicAssessment }`. Validate `body.assessment` exists and `body.assessment.id` exists. Return 400 if invalid.

4. **Token generation**: `const token = crypto.randomUUID();` and `const calKey = \`cal:${token}\`;`

5. **Store snapshot in Redis (ICS-05)**: Store `{ assessment: body.assessment, createdAt: new Date().toISOString() }` with TTL `"calendar_plans"` (365 days). This is the immutable snapshot -- the subscription serves this data regardless of what the user does in their browser.

6. **Build response URLs**:
   - `httpURL`: `${req.nextUrl.origin}/api/cal/${token}` (for direct access/testing)
   - `webcalURL`: Replace `https://` (or `http://`) with `webcal://` in httpURL (ICS-03). Use: `httpURL.replace(/^https?:/, "webcal:")`
   - Calculate `expiresAt` from createdAt + CACHE_TTLS.calendar_plans seconds.

7. **Return 201**: `{ webcalURL, httpURL, token, expiresAt }`

**Step 2: Create `src/app/api/cal/[token]/route.ts` -- GET endpoint serving ICS feed**

This is the subscription endpoint that calendar clients poll (ICS-02).

```typescript
import { NextRequest, NextResponse } from "next/server";
import { cacheGet, isCacheAvailable } from "@/lib/redis";
import { buildICS, buildCalendarEventsFromGrid } from "@/lib/calendar/ics-builder";
import { buildCalendarGrid } from "@/lib/engine/calendar-grid";
import { STATES_MAP } from "@/lib/constants/states";
import type { StrategicAssessment } from "@/lib/types";
```

Implementation:

1. **Extract token**: Next.js 16 uses `{ params }: { params: Promise<{ token: string }> }` -- await it: `const { token } = await params;`

2. **Cache availability**: Return 503 if unavailable.

3. **Retrieve snapshot**: `const snapshot = await cacheGet<{ assessment: StrategicAssessment; createdAt: string }>(\`cal:${token}\`);` Return 404 `{ error: "Calendar not found or expired" }` if null.

4. **Build calendar events for ALL available years** (not just one year):
   ```typescript
   const assessment = snapshot.assessment;
   const allEvents: ICSEventInput[] = [];
   const allTimezones = new Set<string>();

   // Build state timezone map from STATES_MAP
   const stateTimezones: Record<string, string> = {};
   for (const [id, state] of Object.entries(STATES_MAP)) {
     if (state.deadlineTimezone) {
       stateTimezones[id] = state.deadlineTimezone;
     }
   }

   // Generate events for every year in the roadmap
   const availableYears = assessment.roadmap.map(ry => ry.year);
   for (const year of availableYears) {
     const grid = buildCalendarGrid(assessment, year);
     const { events, timezones } = buildCalendarEventsFromGrid(grid, year, stateTimezones);
     allEvents.push(...events);
     timezones.forEach(tz => allTimezones.add(tz));
   }
   ```

5. **Generate ICS**: `const ics = buildICS(allEvents, { timezones: Array.from(allTimezones), calendarName: "Hunt Planner - Odyssey Outdoors" });`

6. **Return with proper headers**:
   ```typescript
   return new NextResponse(ics, {
     headers: {
       "Content-Type": "text/calendar; charset=utf-8",
       "Content-Disposition": 'attachment; filename="hunt-planner.ics"',
       "Cache-Control": "public, max-age=3600",  // 1 hour client cache
     },
   });
   ```
   The 1-hour Cache-Control suggests clients re-poll hourly, though Google Calendar ignores this and uses its own 12-24h interval.

**Step 3: Update `src/middleware.ts` -- exclude /api/cal routes**

Add `api/cal` to the negative lookahead in the middleware matcher pattern. The current pattern is:
```
"/((?!_next/static|_next/image|favicon.ico|api/share|shared/|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)"
```

Update to:
```
"/((?!_next/static|_next/image|favicon.ico|api/share|api/cal|shared/|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)"
```

Add `api/cal|` after `api/share|` in the negative lookahead. Update the comment block to mention `/api/cal` as a public endpoint alongside `/api/share`.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify:
- `grep "export async function POST" src/app/api/cal/route.ts` confirms POST handler
- `grep "export async function GET" src/app/api/cal/[token]/route.ts` confirms GET handler
- `grep "calendar_plans" src/app/api/cal/route.ts` confirms 365d TTL usage
- `grep "text/calendar" src/app/api/cal/[token]/route.ts` confirms Content-Type header
- `grep "webcal:" src/app/api/cal/route.ts` confirms webcal URL generation
- `grep "buildICS" src/app/api/cal/[token]/route.ts` confirms ICS generation
- `grep "buildCalendarGrid" src/app/api/cal/[token]/route.ts` confirms grid usage
- `grep "api/cal" src/middleware.ts` confirms middleware exclusion
- Run `npm run build` to confirm both routes compile in the server build
  </verify>
  <done>POST /api/cal creates a calendar subscription token with plan snapshot in Redis (365d TTL). GET /api/cal/[token] dynamically generates an ICS feed from the stored snapshot using buildICS with VTIMEZONE support. Middleware excludes both routes from auth. The subscription is fully server-side -- independent of browser state (ICS-05).</done>
</task>

<task type="auto">
  <name>Task 2: SubscribeCalendar component + ResultsShell integration</name>
  <files>
    src/components/results/SubscribeCalendar.tsx
    src/components/results/ResultsShell.tsx
  </files>
  <action>
**Step 1: Create `src/components/results/SubscribeCalendar.tsx`**

A client component that handles the full subscription flow: create subscription, display URLs, copy to clipboard, open in calendar app, and regenerate token (ICS-08). Follow the ShareButton pattern but with richer UI since calendar subscription needs more explanation.

```typescript
"use client";

import { useState } from "react";
import type { StrategicAssessment } from "@/lib/types";
import { Button } from "@/components/ui/button";
import { CalendarPlus, Check, Loader2, AlertCircle, Copy, RefreshCw, ExternalLink } from "lucide-react";
```

**State:**
```typescript
type Status = "idle" | "loading" | "ready" | "error";

interface SubscriptionData {
  webcalURL: string;
  httpURL: string;
  token: string;
  expiresAt: string;
}
```

**Props:**
```typescript
interface SubscribeCalendarProps {
  assessment: StrategicAssessment;
}
```

**Component implementation:**

1. **State management:**
   - `status: Status` -- tracks API call state
   - `subscription: SubscriptionData | null` -- holds the active subscription info
   - `copyStatus: "idle" | "copied"` -- for the copy-URL feedback

2. **`handleSubscribe()` function:**
   - Set status to "loading"
   - POST to `/api/cal` with `{ assessment }` body (mirrors ShareButton fetch pattern)
   - Handle errors: 429 (rate limited), 503 (unavailable), other errors -> set status "error", setTimeout to "idle" after 3000ms
   - On success: parse response as `SubscriptionData`, store in state, set status to "ready"

3. **`handleRegenerate()` function (ICS-08):**
   - Same as handleSubscribe() -- creates a new token. Old token continues serving old snapshot in Redis until its 365d TTL expires.
   - Set status to "loading" during regeneration
   - On success: replace subscription data with new values

4. **`handleCopyURL()` function:**
   - Copy `subscription.httpURL` to clipboard (use navigator.clipboard with textarea fallback, same as ShareButton pattern)
   - Set copyStatus to "copied", setTimeout to "idle" after 2500ms

5. **`handleOpenCalendar()` function:**
   - Open the webcal:// URL: `window.open(subscription.webcalURL, "_self")` -- this triggers the native calendar app to open. Using `_self` is important because webcal:// URLs don't open in new tabs.

6. **Render states:**

   **When status is "idle" (no subscription yet):**
   Render a single button:
   ```
   <Button variant="outline" className="gap-1.5" onClick={handleSubscribe}>
     <CalendarPlus className="w-4 h-4" />
     Subscribe to Calendar
   </Button>
   ```

   **When status is "loading":**
   Same button but disabled with spinner:
   ```
   <Button variant="outline" className="gap-1.5" disabled>
     <Loader2 className="w-4 h-4 animate-spin" />
     Creating...
   </Button>
   ```

   **When status is "ready" (subscription exists):**
   Render an expanded panel (not just a button) with:

   a. **Header row:** "Calendar Subscription" with a green checkmark icon, and a close/collapse mechanism (set status back to "idle" but keep subscription data).

   b. **Instruction text:** `"Add to your calendar app for automatic updates. Changes may take up to 24 hours to appear."` in text-xs text-muted-foreground.

   c. **Two action buttons side by side:**
      - "Open in Calendar" button (primary variant): calls handleOpenCalendar(). Icon: ExternalLink. This is the primary CTA.
      - "Copy URL" button (outline variant): calls handleCopyURL(). Icon: Copy or Check (when copied).

   d. **URL display:** Show the httpURL in a small mono font input (readonly, truncated) so users can see what they are subscribing to. `text-[10px] font-mono text-muted-foreground bg-secondary/50 rounded px-2 py-1 truncate`.

   e. **Regenerate row:** Below the URL, a small text link: "Plan changed? [Generate new link]" that calls handleRegenerate(). Include helper text: `"Old subscription continues until expiration."` in text-[10px] text-muted-foreground. Use RefreshCw icon.

   f. **Expiration:** Show `"Expires: ${formatDate(subscription.expiresAt)}"` in text-[10px] text-muted-foreground. Format with `new Date(expiresAt).toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" })`.

   **Overall panel styling:** The expanded panel should be a card-like container: `bg-secondary/30 border border-border rounded-xl p-4 space-y-3`. It appears inline where the button was, pushing sibling content down. Keep it compact -- about 200px wide max.

   **When status is "error":**
   Render button with error state (same as ShareButton):
   ```
   <Button variant="outline" className="gap-1.5 text-destructive" disabled>
     <AlertCircle className="w-4 h-4" />
     Failed
   </Button>
   ```

**Step 2: Modify `src/components/results/ResultsShell.tsx`**

Add the SubscribeCalendar button to the action button row at the bottom of ResultsShell.

Changes:

1. **Import:** Add `import { SubscribeCalendar } from "./SubscribeCalendar";`

2. **Render:** Add `<SubscribeCalendar assessment={assessment} />` in the right-side button group, between PlanExport and ShareButton. The order should be:
   ```
   <PlanExport ... />
   <SubscribeCalendar assessment={assessment} />
   <ShareButton ... />
   <Button onClick={handleConfirmPlan} ...>Confirm & Start Tracking</Button>
   ```

3. **No other changes to ResultsShell.** Do not modify tabs, state, or any other functionality.

**Style notes:**
- Use the app's dark theme colors (oklch-based). Do not hardcode light-theme colors.
- The SubscribeCalendar expanded panel should match the visual weight of other UI elements in the action bar area.
- Use shadcn/ui Button component for all buttons.
- The component should handle its own layout -- it renders either a single button (idle/loading/error) or an expanded card (ready). The parent (ResultsShell action bar) uses flex with gap, so the component width changes are handled naturally.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npm run build` to confirm client components compile. Verify:
- `grep "export function SubscribeCalendar" src/components/results/SubscribeCalendar.tsx` confirms component
- `grep "api/cal" src/components/results/SubscribeCalendar.tsx` confirms API integration
- `grep "webcalURL" src/components/results/SubscribeCalendar.tsx` confirms webcal handling
- `grep "handleRegenerate\|regenerate\|Regenerate\|Generate new" src/components/results/SubscribeCalendar.tsx` confirms token regeneration (ICS-08)
- `grep "import.*SubscribeCalendar" src/components/results/ResultsShell.tsx` confirms integration
- `grep "SubscribeCalendar" src/components/results/ResultsShell.tsx` confirms rendering
  </verify>
  <done>SubscribeCalendar component provides the full subscription flow: create subscription via POST /api/cal, display webcal:// and HTTP URLs, open in native calendar app, copy URL to clipboard, and regenerate token. ResultsShell renders SubscribeCalendar in the action button row alongside PlanExport and ShareButton.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify calendar subscription end-to-end</name>
  <files>
    src/components/results/SubscribeCalendar.tsx
    src/app/api/cal/[token]/route.ts
  </files>
  <action>
Verify the complete calendar subscription feature visually and functionally in the browser. The executor should have the dev server running. This checkpoint confirms the subscription flow works end-to-end: button renders, API creates token, ICS is served, webcal:// opens calendar app, and token regeneration works.
  </action>
  <verify>
Follow the how-to-verify steps below to confirm all visual and functional aspects of the calendar subscription.
  </verify>
  <done>User has visually and functionally confirmed the calendar subscription works end-to-end: Subscribe button in results, expanded panel with URLs, ICS download via HTTP URL, webcal:// opens native calendar, token regeneration creates new link, and old token continues serving.</done>
  <what-built>Complete calendar subscription system: isomorphic ICS builder with stable UIDs and VTIMEZONE support, POST /api/cal endpoint for token creation + Redis snapshot, GET /api/cal/[token] endpoint serving dynamic ICS feed, SubscribeCalendar UI component with webcal:// integration and token regeneration, and middleware exclusion for public access.</what-built>
  <how-to-verify>
1. Start the dev server (`npm run dev`) if not running
2. Navigate to the app and complete (or load) a consultation to see results
3. Scroll to the bottom action bar -- verify "Subscribe to Calendar" button appears between "Export" and "Share Plan"
4. Click "Subscribe to Calendar":
   - Verify loading spinner appears briefly
   - Verify expanded panel appears with "Open in Calendar" and "Copy URL" buttons
   - Verify the HTTP URL is displayed in a mono-font field
   - Verify expiration date is shown (~365 days from now)
5. Click "Copy URL" -- verify clipboard contains the URL, button shows checkmark feedback
6. Open the HTTP URL directly in browser (paste from clipboard):
   - Verify the browser downloads or displays a .ics file
   - Verify the content starts with BEGIN:VCALENDAR and contains METHOD:PUBLISH
   - Verify events have stable UIDs (contain @odysseyoutdoors.com)
   - Verify CRLF line endings (check with hex viewer or note the file opens correctly)
7. Click "Open in Calendar":
   - On macOS: Verify Apple Calendar opens with a subscription prompt
   - On other OS: Verify the webcal:// URL triggers the default calendar handler
8. Test token regeneration:
   - Click "Generate new link" in the panel
   - Verify a new URL is generated (different token in the URL)
   - Verify old URL still works (open both in browser to confirm)
9. Verify error handling:
   - If Redis is not configured (no env vars), the dev fallback should work
   - The component should handle 503 gracefully (shows error state)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the subscription flow</resume-signal>
</task>

</tasks>

<technical_notes>
- The POST /api/cal endpoint stores the ENTIRE StrategicAssessment in Redis. This is intentional -- the GET endpoint needs it to regenerate the calendar grid dynamically for all years. Assessment objects are typically 50-100KB JSON, well within Redis value limits.
- webcal:// protocol works by replacing the scheme in the URL. Calendar apps recognize it and offer to subscribe. Using `window.open(webcalURL, "_self")` works better than `_blank` because webcal:// doesn't create a new tab -- it hands off to the OS calendar handler.
- The GET endpoint generates ICS dynamically on each request (not cached as a pre-generated file). This means if the ICS builder logic is updated, all existing subscriptions benefit without token regeneration. The snapshot is the assessment data, not the ICS output.
- Token regeneration (ICS-08) creates a completely new token and Redis entry. The old token is NOT invalidated -- it continues serving its original snapshot for its remaining TTL (up to 365 days). This matches the share link pattern and avoids breaking existing calendar subscriptions.
- Google Calendar and Outlook poll subscriptions every 12-24 hours regardless of Cache-Control headers. The 1-hour max-age is a suggestion that Apple Calendar may respect. The UI copy ("Changes may take up to 24 hours") sets user expectations per research.
- The middleware exclusion uses `api/cal` (no trailing pipe or slash) which matches both `/api/cal` (POST) and `/api/cal/xxx` (GET) routes.
</technical_notes>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- POST /api/cal returns 201 with webcalURL, httpURL, token, expiresAt
- GET /api/cal/[token] returns text/calendar with valid ICS content
- GET /api/cal/[nonexistent] returns 404
- ICS content has BEGIN:VCALENDAR, METHOD:PUBLISH, stable UIDs, VTIMEZONE blocks
- SubscribeCalendar renders in ResultsShell action bar
- webcal:// URL triggers native calendar app
- Token regeneration creates new subscription without breaking old one
- Middleware excludes /api/cal from auth processing
</verification>

<success_criteria>
1. User clicks "Subscribe to Calendar" and receives a webcal:// URL that opens in Google Calendar or Apple Calendar (ICS-03, success criterion 1)
2. GET /api/cal/[token] serves dynamically-generated ICS from Redis snapshot (ICS-02, ICS-05, success criteria 2 and 4)
3. Token regeneration creates new subscription; old token continues serving its snapshot (ICS-08, success criterion 5)
4. The entire flow works without requiring user browser state -- purely server-side (ICS-05, success criterion 4)
5. Stable UIDs from Plan 01 prevent duplicate events on calendar refresh (ICS-04, success criterion 3)
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-subscription/04-02-SUMMARY.md`
</output>
