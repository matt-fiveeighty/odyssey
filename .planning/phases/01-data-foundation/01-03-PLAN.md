---
phase: 01-data-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/lib/engine/data-loader.ts
autonomous: true

must_haves:
  truths:
    - "Data resolution follows three tiers: live scrape (Supabase) > cached last-known-good (Redis) > hardcoded constants"
    - "When Supabase returns data, it is cached to Redis as last-known-good before being used"
    - "When Supabase fails but Redis has cached data, the app uses cached data instead of falling through to constants"
    - "When both Supabase and Redis are unavailable, the app renders with hardcoded constants"
    - "DataStatus reports which tier provided the data (db, cache, constants)"
    - "The app renders with reasonable data even when all external sources are disabled"
  artifacts:
    - path: "src/lib/engine/data-loader.ts"
      provides: "Three-tier data resolution with Redis cache middle layer"
      exports: ["loadDataContext", "refreshDataContext", "getDataStatus", "DataStatus"]
      contains: "cacheGet|cacheSet"
  key_links:
    - from: "src/lib/engine/data-loader.ts"
      to: "src/lib/redis.ts"
      via: "import { cacheGet, cacheSet } for Redis cache tier"
      pattern: "import.*cacheGet.*cacheSet.*from.*redis"
    - from: "src/lib/engine/data-loader.ts"
      to: "src/lib/engine/roadmap-generator.ts"
      via: "setDataContext() to update engine with resolved data"
      pattern: "setDataContext"
    - from: "src/lib/engine/data-loader.ts"
      to: "@supabase/supabase-js"
      via: "createClient for live scrape tier"
      pattern: "createClient"
---

<objective>
Wire the three-tier data resolution chain (live Supabase > cached Redis > hardcoded constants) into the existing data-loader, ensuring the app always renders with reasonable data regardless of which external services are available.

Purpose: DATA-02 requires that the app never shows empty data. Currently data-loader.ts has a two-tier system (Supabase > constants). Adding Redis as the middle tier means a Supabase outage no longer drops straight to stale hardcoded data -- it serves the most recently cached good data instead. This is the last piece of Phase 1 infrastructure.

Output: Modified `src/lib/engine/data-loader.ts` with Redis cache integration
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@.planning/phases/01-data-foundation/01-02-SUMMARY.md

@src/lib/engine/data-loader.ts
@src/lib/redis.ts
@src/lib/engine/verified-datum.ts
@src/lib/engine/roadmap-generator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis cache tier to data-loader.ts</name>
  <files>src/lib/engine/data-loader.ts</files>
  <action>
    Modify `src/lib/engine/data-loader.ts` to implement three-tier resolution:

    1. **Add imports** at top:
       ```
       import { cacheGet, cacheSet } from "@/lib/redis";
       ```

    2. **Define cache keys** (constants near top of file):
       ```
       const CACHE_KEY_UNITS = "data:units:latest";
       const CACHE_KEY_DEADLINES = "data:deadlines:latest";
       const CACHE_KEY_TTL = 24 * 60 * 60; // 24 hours — longer than the 5min in-memory cache, shorter than scrape cadence
       ```

    3. **Update DataStatus type** to support three sources:
       Change `source: "db" | "constants"` to `source: "db" | "cache" | "constants"`
       Update `_dataSource` variable type and default accordingly.

    4. **Modify `_loadDataContextInner()`** to implement three-tier resolution:

       Current flow: Supabase query -> success: use DB data, fail: use constants
       New flow:

       ```
       Tier 1 — Try Supabase (live scrape):
         If Supabase configured and query succeeds:
           - Merge DB data with constants (existing logic)
           - Cache merged units and merged deadlines to Redis (fire-and-forget, don't await)
           - Set _dataSource = "db"
           - Return

       Tier 2 — Try Redis cache (last-known-good):
         If Supabase failed OR unconfigured:
           - Try cacheGet<DbUnit[]>(CACHE_KEY_UNITS) and cacheGet<DbDeadline[]>(CACHE_KEY_DEADLINES)
           - If cache hit (units exist and are non-empty):
             - Merge cached data with constants (reuse existing merge functions)
             - Set _dataSource = "cache"
             - Return

       Tier 3 — Hardcoded constants (always available):
         - resetDataContext() (existing behavior)
         - Set _dataSource = "constants"
       ```

    5. **Cache write after successful Supabase load** (in the success path of tier 1):
       ```
       // Fire-and-forget cache write — don't block the response
       cacheSet(CACHE_KEY_UNITS, dbUnits, CACHE_KEY_TTL).catch(() => {});
       if (dbDeadlines?.length) {
         cacheSet(CACHE_KEY_DEADLINES, dbDeadlines, CACHE_KEY_TTL).catch(() => {});
       }
       ```
       Use raw TTL number (24 hours) rather than a preset key since this is a custom data caching scenario.

    6. **Preserve all existing behavior:**
       - 5-minute in-memory cache (CACHE_TTL_MS) stays as-is — it's a process-level dedup, not the Redis tier
       - Concurrent request deduplication (_pendingLoad) stays
       - mergeUnits() and mergeDeadlines() functions stay unchanged
       - STALE_THRESHOLD_DAYS stays (used by getDataStatus)
       - refreshDataContext() stays (bypasses in-memory cache, re-runs three-tier)

    7. **Error handling:** Every Redis call is wrapped in try/catch or uses .catch(() => {}). Redis failures must never prevent the app from rendering. Log warnings via logger.warn when cache tier is attempted and fails.

    IMPORTANT: Do NOT wrap individual data values in VerifiedDatum in this plan. This plan only adds the Redis cache tier to the data resolution chain. VerifiedDatum wrapping of individual State/Unit fields happens in Phase 2+ per the gradual adoption strategy in ARCHITECTURE.md.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - data-loader.ts imports cacheGet and cacheSet from "@/lib/redis"
    - DataStatus.source type includes "cache" as a valid value
    - `grep -n "cacheSet\|cacheGet" src/lib/engine/data-loader.ts` shows both being used
    - `grep -n "resetDataContext" src/lib/engine/data-loader.ts` still present (tier 3 fallback)
  </verify>
  <done>
    data-loader.ts implements three-tier resolution (Supabase > Redis > constants). Successful Supabase loads cache to Redis. Failed Supabase loads try Redis before falling to constants. All Redis operations are fire-and-forget or gracefully degrading.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate fallback chain and update data status reporting</name>
  <files>src/lib/engine/data-loader.ts</files>
  <action>
    1. **Update getDataStatus()** to report the new "cache" source:
       - When _dataSource === "cache", isUsingConstants should be false (we have real-ish data, just not live)
       - Add a new field `tier: 1 | 2 | 3` to DataStatus for explicit tier reporting:
         - db = tier 1, cache = tier 2, constants = tier 3
       - Update the isStale computation: cache tier data should use the cached scrape timestamp if available, not the local _lastLoadedAt

    2. **Add _cachedScrapeTimestamp tracking:**
       - When loading from Redis cache (tier 2), store the timestamp of when the cached data was originally scraped (if that metadata exists in the cached payload)
       - If not available, mark staleDays as null and isStale as true (conservative assumption)

    3. **Verify the entire fallback chain logic by reading through the flow:**
       - Scenario A: Supabase configured, query succeeds -> tier 1, cache write, return
       - Scenario B: Supabase configured, query fails -> try Redis cache -> hit: tier 2, return
       - Scenario C: Supabase configured, query fails -> try Redis cache -> miss: tier 3, constants
       - Scenario D: Supabase unconfigured (no env vars) -> try Redis cache -> hit: tier 2, return
       - Scenario E: Supabase unconfigured, Redis unconfigured -> tier 3, constants
       - All 5 scenarios must resolve without throwing

    4. **Update logger messages** to indicate which tier resolved:
       ```
       logger.info("[data-loader] Tier 1: Loaded from Supabase (X units, Y deadlines)")
       logger.info("[data-loader] Tier 2: Loaded from Redis cache")
       logger.warn("[data-loader] Tier 3: Falling back to hardcoded constants")
       ```

    IMPORTANT: Do NOT write unit tests for this in this plan. The data-loader requires Supabase and Redis connections to test properly, and integration tests belong in a later phase. The verification is structural (type-check + grep for expected patterns).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - DataStatus type includes `tier: 1 | 2 | 3`
    - DataStatus.source accepts "db" | "cache" | "constants"
    - Logger output includes tier indicators
    - No uncaught promise rejections possible (all Redis/Supabase calls wrapped)
  </verify>
  <done>
    DataStatus accurately reports which resolution tier provided data. All 5 fallback scenarios resolve without error. Logger messages indicate tier for debugging.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx next build` completes without errors (full build validates imports and server component compatibility)
- data-loader.ts has three distinct resolution paths (Supabase, Redis, constants)
- No raw `new Redis()` calls in data-loader.ts (uses shared client via redis.ts helpers)
- Existing behavior preserved: 5-minute in-memory cache, concurrent dedup, merge functions
</verification>

<success_criteria>
- Three-tier data resolution is operational: Supabase > Redis > constants
- Successful Supabase loads write to Redis cache for next time
- Redis cache failures never crash the app -- silently fall through to constants
- DataStatus correctly reports which tier provided data
- The app renders normally when ALL external services (Supabase + Redis) are unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-03-SUMMARY.md`
</output>
