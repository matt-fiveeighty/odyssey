---
phase: 01-data-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/redis.ts
  - src/lib/rate-limit.ts
autonomous: true

must_haves:
  truths:
    - "Any server-side module can import getRedis() from src/lib/redis.ts and get a shared Upstash Redis client"
    - "rate-limit.ts imports getRedis from redis.ts instead of maintaining its own client instance"
    - "cacheGet and cacheSet helpers support configurable TTLs for different data categories"
    - "Cache helpers degrade gracefully when Redis is unavailable (return null on get, no-op on set)"
    - "TTL presets exist for flight_prices (6h), cpi_data (30d), share_links (90d), calendar_plans (365d)"
  artifacts:
    - path: "src/lib/redis.ts"
      provides: "Shared Redis client, cacheGet, cacheSet, TTL presets"
      exports: ["getRedis", "cacheGet", "cacheSet", "CACHE_TTLS"]
    - path: "src/lib/rate-limit.ts"
      provides: "Rate limiting (unchanged behavior, refactored to use shared client)"
      contains: "import.*getRedis.*from.*redis"
  key_links:
    - from: "src/lib/rate-limit.ts"
      to: "src/lib/redis.ts"
      via: "import { getRedis } from './redis'"
      pattern: "import.*getRedis.*from.*['\"]\\./redis['\"]"
    - from: "src/lib/redis.ts"
      to: "@upstash/redis"
      via: "Redis client instantiation"
      pattern: "new Redis"
---

<objective>
Extract the shared Upstash Redis client from rate-limit.ts into a standalone module, and add typed cache helpers with configurable TTLs for the four data categories downstream phases need.

Purpose: DATA-03 (shared Redis client) and DATA-04 (cache helpers with TTLs) provide the caching infrastructure that share links (Phase 2), calendar subscriptions (Phase 4), flight prices (Phase 6), and CPI data (Phase 6) all depend on. Extracting now prevents duplicated Redis clients across modules.

Output: `src/lib/redis.ts` (new shared module), `src/lib/rate-limit.ts` (refactored to use shared client)
</objective>

<execution_context>
@/Users/mattramirez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mattramirez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/rate-limit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared Redis client and create cache helpers</name>
  <files>src/lib/redis.ts</files>
  <action>
    Create `src/lib/redis.ts` with the following:

    1. **Shared Redis client** (extracted from rate-limit.ts):
       ```
       import { Redis } from "@upstash/redis";
       let redis: Redis | null = null;
       export function getRedis(): Redis | null { ... }
       ```
       Exact same lazy-init pattern currently in rate-limit.ts: reads UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN from env, returns null if missing.

    2. **TTL presets** (exported constant):
       ```
       export const CACHE_TTLS = {
         flight_prices: 6 * 60 * 60,        // 6 hours in seconds
         cpi_data: 30 * 24 * 60 * 60,       // 30 days
         share_links: 90 * 24 * 60 * 60,    // 90 days
         calendar_plans: 365 * 24 * 60 * 60, // 365 days
         default: 60 * 60,                   // 1 hour fallback
       } as const;
       export type CacheTTLKey = keyof typeof CACHE_TTLS;
       ```

    3. **cacheGet helper**:
       ```
       export async function cacheGet<T>(key: string): Promise<T | null>
       ```
       - Gets the Redis client via getRedis()
       - If no client (Redis unconfigured), return null
       - Calls redis.get(key), returns parsed result or null
       - Wraps in try/catch, returns null on any error (graceful degradation)

    4. **cacheSet helper**:
       ```
       export async function cacheSet<T>(key: string, value: T, ttl: CacheTTLKey | number): Promise<void>
       ```
       - Gets the Redis client via getRedis()
       - If no client, return (no-op)
       - If ttl is a string key, look up seconds from CACHE_TTLS
       - If ttl is a number, use it directly as seconds
       - Calls redis.set(key, JSON.stringify(value), { ex: ttlSeconds })
       - Wraps in try/catch, silently fails (graceful degradation)

    5. **cacheDel helper** (for completeness):
       ```
       export async function cacheDel(key: string): Promise<void>
       ```
       - Deletes a cache key. Graceful no-op if Redis unavailable.

    Do NOT add any test file in this plan. The cache helpers are integration-tested via the three-tier resolution in plan 01-03.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/lib/redis.ts` exports getRedis, cacheGet, cacheSet, cacheDel, CACHE_TTLS
  </verify>
  <done>
    redis.ts exists with shared client and cache helpers. All exports type-check. Graceful degradation when Redis env vars are missing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor rate-limit.ts to use shared Redis client</name>
  <files>src/lib/rate-limit.ts</files>
  <action>
    Modify `src/lib/rate-limit.ts`:

    1. Remove the local `redis` variable and `getRedis()` function (lines 5-14 of current file)
    2. Add import: `import { getRedis } from "./redis";`
    3. The `createLimiter` function already calls `getRedis()` -- it should now use the imported version with zero behavior change
    4. All existing exports (limiters, RateLimitResult, checkRateLimit) remain unchanged

    This is a pure refactor. The only behavioral change is that the Redis instance is now shared across modules instead of being private to rate-limit.ts.

    Verify that no other file in the codebase creates its own Redis instance (grep for `new Redis` in src/ excluding node_modules). If any exist, note them in the summary but do NOT refactor them in this plan.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `grep -r "new Redis" src/` only shows the single instance in src/lib/redis.ts
    - rate-limit.ts imports getRedis from "./redis"
    - rate-limit.ts no longer contains `let redis` or `function getRedis`
  </verify>
  <done>
    rate-limit.ts uses the shared Redis client from redis.ts. No duplicate Redis instances in src/. All existing rate-limit behavior is preserved.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `grep -rn "new Redis" src/` shows exactly one hit in src/lib/redis.ts
- `grep -rn "getRedis" src/lib/rate-limit.ts` shows import from "./redis"
- The app builds without errors: `npx next build` (or at minimum `npx tsc --noEmit`)
</verification>

<success_criteria>
- Single shared Redis client in src/lib/redis.ts used by rate-limit.ts (and available to all future consumers)
- Cache helpers (cacheGet, cacheSet, cacheDel) work with both TTL preset keys and raw seconds
- All helpers degrade gracefully when Redis is unavailable (no throws, no crashes)
- rate-limit.ts behavior is identical before and after the refactor
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
