# Phase 1: Cloud Persistence — Wire All User Data to Supabase

## Key Discovery
**The DB tables already exist.** Supabase already has `assessments`, `user_goals`, `wizard_state`, `savings_goals`, `budget_plans`, and `user_points` tables with RLS policies. The only working sync is `user_points`. Everything else is disconnected.

## Architecture Decision: Bulk Sync Endpoint
Instead of 6 separate API endpoints (one per data type), we build **one bulk sync endpoint** — `POST /api/user/sync` for writes and `GET /api/user/sync` for full hydration. This means:
- **1 network request on login** (not 6)
- **1 debounced sync call** on mutations (not 6)
- Atomic: all data arrives together, no partial states

## Store → DB Table Mapping

| Store Field | DB Table | Strategy |
|---|---|---|
| `savedPlans` | `assessments` | Add `name`, `label`, `is_active` columns |
| `userGoals` | `user_goals` | Already exists — wire up (milestones embedded as JSONB) |
| `milestones` | embedded in `user_goals.milestones` | No separate table needed |
| `savingsGoals` | `savings_goals` | Already exists — wire up |
| `fiduciaryAlerts` | NEW `fiduciary_alerts` table | Create table |
| `scheduleConflicts` | embedded in fiduciary_alerts JSONB | No separate table |
| `activePlanId` | derived from `assessments.is_active` | No extra table |
| Wizard state | `wizard_state` | Already exists — wire up |

---

## Implementation Steps

### Step 1: SQL Migration
**New file: `supabase-migration-cloud-persist.sql`**

- ALTER `assessments`: add `name TEXT`, `label TEXT`, `is_active BOOLEAN`, `updated_at TIMESTAMPTZ`
- CREATE `fiduciary_alerts` table with RLS
- Add indexes for `assessments(user_id, is_active)` and `fiduciary_alerts(user_id)`
- User runs this manually against their Supabase instance

### Step 2: Bulk Sync API Route
**New file: `src/app/api/user/sync/route.ts`**

**GET** — Fetches ALL user data in parallel from 5 tables:
- `assessments` → `savedPlans` (camelCase mapping)
- `user_goals` → `userGoals` (milestones are JSONB within goals)
- `savings_goals` → `savingsGoals`
- `fiduciary_alerts` → `fiduciaryAlerts`
- `user_points` → `userPoints`
- `wizard_state` → wizard store snapshot

Returns `{ plans, goals, savings, alerts, points, wizardState, activePlanId }`

**POST** — Upserts ALL user data atomically:
- Maps each store section to its table using conflict keys
- Assessment conflict: `(user_id, id)` — upsert with input/result JSONB
- Goals conflict: `(user_id, id)` — upsert with milestones embedded
- Savings conflict: `(user_id, id)`
- Alerts conflict: `(user_id, alert_id)`
- Points conflict: `(user_id, state_id, species_id, point_type)`

Pattern follows existing `/api/user/points` — `createServerSupabase()`, auth check, snake_case DB columns.

### Step 3: Sync Manager
**New file: `src/lib/sync.ts`**

Replaces inline `syncPointsToDb()`:

```
syncAllToDb()     — debounced (800ms), POST /api/user/sync with full state
hydrateFromDb()   — GET /api/user/sync → populate all 3 stores
getSyncStatus()   — 'idle' | 'syncing' | 'error' for UI indicator
```

- Single shared debounce timer (800ms after last mutation)
- Silent fail — local store stays authoritative (offline-first)
- Exported for AuthProvider and store actions
- Maps between Zustand camelCase types and DB snake_case

### Step 4: Wire Sync into Store
**Modify: `src/lib/store.ts`**

Remove `syncPointsToDb()` function (replaced by sync.ts).

Add `syncAllToDb()` call to every mutating action:
- Points: `addUserPoint`, `updateUserPoint`, `removeUserPoint`
- Goals: `addUserGoal`, `updateUserGoal`, `removeUserGoal`
- Milestones: `completeMilestone`, `uncompleteMilestone`, `setDrawOutcome`
- Plans: `savePlan`, `renamePlan`, `deletePlan`, `switchPlan`, `setConfirmedAssessment`
- Savings: `addSavingsGoal`, `updateSavingsGoal`, `removeSavingsGoal`, `addContribution`
- Alerts: `dismissFiduciaryAlert`, `clearFiduciaryAlerts`
- Cascade: `setDrawOutcomeCascade`

Each action gets ONE additional line at the end: `syncAllToDb();`

Wizard store: sync on `confirmPlan()` only (not every field change — too noisy during 9-step flow).

### Step 5: Wire Hydration into AuthProvider
**Modify: `src/components/providers/AuthProvider.tsx`**

After successful auth:
1. Call `hydrateFromDb()`
2. Merge strategy: DB data wins if local store is empty for that section. If both have data, use whichever `updatedAt` is newer.
3. Add `hydrated` state to context so pages can show loading until data arrives

### Step 6: Tests
**New file: `src/lib/engine/__tests__/cloud-persistence.test.ts`**

- camelCase↔snake_case mapping roundtrips
- Debounce: 5 rapid mutations → 1 sync call
- Hydration merge: empty local + full DB → use DB
- Hydration merge: full local + stale DB → keep local
- Assessment JSONB serialization roundtrip
- Alert deduplication (same alert_id)
- Graceful degradation (fetch throws → local store unaffected)
- Wizard state: only syncs on confirmPlan, not on setField

---

## Files Summary

### Created (4 files)
1. `supabase-migration-cloud-persist.sql` — Schema changes
2. `src/app/api/user/sync/route.ts` — Bulk sync endpoint
3. `src/lib/sync.ts` — Sync manager
4. `src/lib/engine/__tests__/cloud-persistence.test.ts` — Tests

### Modified (2 files)
1. `src/lib/store.ts` — Replace `syncPointsToDb` with `syncAllToDb`, add sync calls to all actions
2. `src/components/providers/AuthProvider.tsx` — Add `hydrateFromDb()` on login

---

## What This Fixes
- ✅ 10-year strategic plan survives cache clear
- ✅ Goals and milestones persist to cloud
- ✅ Fiduciary alerts persist across devices
- ✅ Savings goals don't vanish on browser switch
- ✅ Cross-device access (phone ↔ laptop)
- ✅ Single network request on login
- ✅ Offline-first: localStorage is always authoritative, Supabase is async backup

## What This Defers
- Schema migration V1→V2 auto-upgrade (on ice)
- Simultaneous multi-device conflict resolution (Beta limitation — last write wins)
- Wizard auto-save during steps (only saves completed plans)
